{"/home/travis/build/npmtest/node-npmtest-bpmn-js/test.js":"/* istanbul instrument in package npmtest_bpmn_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/lib.npmtest_bpmn_js.js":"/* istanbul instrument in package npmtest_bpmn_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bpmn_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bpmn_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bpmn-js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bpmn_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bpmn_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bpmn_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bpmn_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bpmn_js.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bpmn_js.__dirname + '/lib.npmtest_bpmn_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/index.js":"module.exports = require('./lib/Viewer');","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/Viewer.js":"/**\n * The code in the <project-logo></project-logo> area\n * must not be changed.\n *\n * @see http://bpmn.io/license for more information.\n */\n'use strict';\n\nvar assign = require('lodash/object/assign'),\n    omit = require('lodash/object/omit'),\n    isNumber = require('lodash/lang/isNumber');\n\nvar domify = require('min-dom/lib/domify'),\n    domQuery = require('min-dom/lib/query'),\n    domRemove = require('min-dom/lib/remove');\n\nvar innerSVG = require('tiny-svg/lib/innerSVG');\n\nvar Diagram = require('diagram-js'),\n    BpmnModdle = require('bpmn-moddle');\n\n\nvar inherits = require('inherits');\n\nvar Importer = require('./import/Importer');\n\n\nfunction checkValidationError(err) {\n\n  // check if we can help the user by indicating wrong BPMN 2.0 xml\n  // (in case he or the exporting tool did not get that right)\n\n  var pattern = /unparsable content <([^>]+)> detected([\\s\\S]*)$/;\n  var match = pattern.exec(err.message);\n\n  if (match) {\n    err.message =\n      'unparsable content <' + match[1] + '> detected; ' +\n      'this may indicate an invalid BPMN 2.0 diagram file' + match[2];\n  }\n\n  return err;\n}\n\nvar DEFAULT_OPTIONS = {\n  width: '100%',\n  height: '100%',\n  position: 'relative'\n};\n\n\n/**\n * Ensure the passed argument is a proper unit (defaulting to px)\n */\nfunction ensureUnit(val) {\n  return val + (isNumber(val) ? 'px' : '');\n}\n\n/**\n * A viewer for BPMN 2.0 diagrams.\n *\n * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include\n * additional features.\n *\n *\n * ## Extending the Viewer\n *\n * In order to extend the viewer pass extension modules to bootstrap via the\n * `additionalModules` option. An extension module is an object that exposes\n * named services.\n *\n * The following example depicts the integration of a simple\n * logging component that integrates with interaction events:\n *\n *\n * ```javascript\n *\n * // logging component\n * function InteractionLogger(eventBus) {\n *   eventBus.on('element.hover', function(event) {\n *     console.log()\n *   })\n * }\n *\n * InteractionLogger.$inject = [ 'eventBus' ]; // minification save\n *\n * // extension module\n * var extensionModule = {\n *   __init__: [ 'interactionLogger' ],\n *   interactionLogger: [ 'type', InteractionLogger ]\n * };\n *\n * // extend the viewer\n * var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });\n * bpmnViewer.importXML(...);\n * ```\n *\n * @param {Object} [options] configuration options to pass to the viewer\n * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\n * @param {String|Number} [options.width] the width of the viewer\n * @param {String|Number} [options.height] the height of the viewer\n * @param {Object} [options.moddleExtensions] extension packages to provide\n * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\n * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\n */\nfunction Viewer(options) {\n\n  options = assign({}, DEFAULT_OPTIONS, options);\n\n  this.moddle = this._createModdle(options);\n\n  this.container = this._createContainer(options);\n\n  /* <project-logo> */\n\n  addProjectLogo(this.container);\n\n  /* </project-logo> */\n\n  this._init(this.container, this.moddle, options);\n}\n\ninherits(Viewer, Diagram);\n\nmodule.exports = Viewer;\n\n\n/**\n * Parse and render a BPMN 2.0 diagram.\n *\n * Once finished the viewer reports back the result to the\n * provided callback function with (err, warnings).\n *\n * ## Life-Cycle Events\n *\n * During import the viewer will fire life-cycle events:\n *\n *   * import.parse.start (about to read model from xml)\n *   * import.parse.complete (model read; may have worked or not)\n *   * import.render.start (graphical import start)\n *   * import.render.complete (graphical import finished)\n *   * import.done (everything done)\n *\n * You can use these events to hook into the life-cycle.\n *\n * @param {String} xml the BPMN 2.0 xml\n * @param {Function} [done] invoked with (err, warnings=[])\n */\nViewer.prototype.importXML = function(xml, done) {\n\n  // done is optional\n  done = done || function() {};\n\n  var self = this;\n\n  // hook in pre-parse listeners +\n  // allow xml manipulation\n  xml = this._emit('import.parse.start', { xml: xml }) || xml;\n\n  this.moddle.fromXML(xml, 'bpmn:Definitions', function(err, definitions, context) {\n\n    // hook in post parse listeners +\n    // allow definitions manipulation\n    definitions = self._emit('import.parse.complete', {\n      error: err,\n      definitions: definitions,\n      context: context\n    }) || definitions;\n\n    if (err) {\n      err = checkValidationError(err);\n\n      self._emit('import.done', { error: err });\n\n      return done(err);\n    }\n\n    var parseWarnings = context.warnings;\n\n    self.importDefinitions(definitions, function(err, importWarnings) {\n      var allWarnings = [].concat(parseWarnings, importWarnings || []);\n\n      self._emit('import.done', { error: err, warnings: allWarnings });\n\n      done(err, allWarnings);\n    });\n  });\n};\n\n/**\n * Export the currently displayed BPMN 2.0 diagram as\n * a BPMN 2.0 XML document.\n *\n * @param {Object} [options] export options\n * @param {Boolean} [options.format=false] output formated XML\n * @param {Boolean} [options.preamble=true] output preamble\n *\n * @param {Function} done invoked with (err, xml)\n */\nViewer.prototype.saveXML = function(options, done) {\n\n  if (!done) {\n    done = options;\n    options = {};\n  }\n\n  var definitions = this.definitions;\n\n  if (!definitions) {\n    return done(new Error('no definitions loaded'));\n  }\n\n  this.moddle.toXML(definitions, options, done);\n};\n\n/**\n * Export the currently displayed BPMN 2.0 diagram as\n * an SVG image.\n *\n * @param {Object} [options]\n * @param {Function} done invoked with (err, svgStr)\n */\nViewer.prototype.saveSVG = function(options, done) {\n\n  if (!done) {\n    done = options;\n    options = {};\n  }\n\n  var canvas = this.get('canvas');\n\n  var contentNode = canvas.getDefaultLayer(),\n      defsNode = domQuery('defs', canvas._svg);\n\n  var contents = innerSVG(contentNode),\n      defs = (defsNode && defsNode.outerHTML) || '';\n\n  var bbox = contentNode.getBBox();\n\n  var svg =\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' +\n    '<!-- created with bpmn-js / http://bpmn.io -->\\n' +\n    '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n' +\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n         'width=\"' + bbox.width + '\" height=\"' + bbox.height + '\" ' +\n         'viewBox=\"' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '\" version=\"1.1\">' +\n      defs + contents +\n    '</svg>';\n\n  done(null, svg);\n};\n\n/**\n * Get a named diagram service.\n *\n * @example\n *\n * var elementRegistry = viewer.get('elementRegistry');\n * var startEventShape = elementRegistry.get('StartEvent_1');\n *\n * @param {String} name\n *\n * @return {Object} diagram service instance\n *\n * @method Viewer#get\n */\n\n/**\n * Invoke a function in the context of this viewer.\n *\n * @example\n *\n * viewer.invoke(function(elementRegistry) {\n *   var startEventShape = elementRegistry.get('StartEvent_1');\n * });\n *\n * @param {Function} fn to be invoked\n *\n * @return {Object} the functions return value\n *\n * @method Viewer#invoke\n */\n\n/**\n * Remove all drawn elements from the viewer.\n *\n * After calling this method the viewer can still\n * be reused for opening another diagram.\n *\n * @method Viewer#clear\n */\n\nViewer.prototype.importDefinitions = function(definitions, done) {\n\n  // use try/catch to not swallow synchronous exceptions\n  // that may be raised during model parsing\n  try {\n\n    if (this.definitions) {\n      // clear existing rendered diagram\n      this.clear();\n    }\n\n    // update definitions\n    this.definitions = definitions;\n\n    // perform graphical import\n    Importer.importBpmnDiagram(this, definitions, done);\n  } catch (e) {\n\n    // handle synchronous errors\n    done(e);\n  }\n};\n\nViewer.prototype.getModules = function() {\n  return this._modules;\n};\n\n/**\n * Destroy the viewer instance and remove all its\n * remainders from the document tree.\n */\nViewer.prototype.destroy = function() {\n\n  // diagram destroy\n  Diagram.prototype.destroy.call(this);\n\n  // dom detach\n  domRemove(this.container);\n};\n\n/**\n * Register an event listener\n *\n * Remove a previously added listener via {@link #off(event, callback)}.\n *\n * @param {String} event\n * @param {Number} [priority]\n * @param {Function} callback\n * @param {Object} [that]\n */\nViewer.prototype.on = function(event, priority, callback, target) {\n  return this.get('eventBus').on(event, priority, callback, target);\n};\n\n/**\n * De-register an event listener\n *\n * @param {String} event\n * @param {Function} callback\n */\nViewer.prototype.off = function(event, callback) {\n  this.get('eventBus').off(event, callback);\n};\n\nViewer.prototype.attachTo = function(parentNode) {\n\n  if (!parentNode) {\n    throw new Error('parentNode required');\n  }\n\n  // ensure we detach from the\n  // previous, old parent\n  this.detach();\n\n  // unwrap jQuery if provided\n  if (parentNode.get && parentNode.constructor.prototype.jquery) {\n    parentNode = parentNode.get(0);\n  }\n\n  if (typeof parentNode === 'string') {\n    parentNode = domQuery(parentNode);\n  }\n\n  var container = this._container;\n\n  parentNode.appendChild(container);\n\n  this._emit('attach', {});\n};\n\nViewer.prototype.detach = function() {\n\n  var container = this._container,\n      parentNode = container.parentNode;\n\n  if (!parentNode) {\n    return;\n  }\n\n  this._emit('detach', {});\n\n  parentNode.removeChild(container);\n};\n\nViewer.prototype._init = function(container, moddle, options) {\n\n  this._container = container;\n  var baseModules = options.modules || this.getModules(),\n      additionalModules = options.additionalModules || [],\n      staticModules = [\n        {\n          bpmnjs: [ 'value', this ],\n          moddle: [ 'value', moddle ]\n        }\n      ];\n\n  var diagramModules = [].concat(staticModules, baseModules, additionalModules);\n\n  var diagramOptions = assign(omit(options, 'additionalModules'), {\n    canvas: assign({}, options.canvas, { container: container }),\n    modules: diagramModules\n  });\n\n  // invoke diagram constructor\n  Diagram.call(this, diagramOptions);\n\n  if (options && options.container) {\n    this.attachTo(options.container);\n  }\n};\n\n/**\n * Emit an event on the underlying {@link EventBus}\n *\n * @param  {String} type\n * @param  {Object} event\n *\n * @return {Object} event processing result (if any)\n */\nViewer.prototype._emit = function(type, event) {\n  return this.get('eventBus').fire(type, event);\n};\n\nViewer.prototype._createContainer = function(options) {\n\n  var container = domify('<div class=\"bjs-container\"></div>');\n\n  assign(container.style, {\n    width: ensureUnit(options.width),\n    height: ensureUnit(options.height),\n    position: options.position\n  });\n\n  return container;\n};\n\nViewer.prototype._createModdle = function(options) {\n  var moddleOptions = assign({}, this._moddleExtensions, options.moddleExtensions);\n\n  return new BpmnModdle(moddleOptions);\n};\n\n\n// modules the viewer is composed of\nViewer.prototype._modules = [\n  require('./core'),\n  require('diagram-js/lib/i18n/translate'),\n  require('diagram-js/lib/features/selection'),\n  require('diagram-js/lib/features/overlays')\n];\n\n// default moddle extensions the viewer is composed of\nViewer.prototype._moddleExtensions = {};\n\n/* <project-logo> */\n\nvar PoweredBy = require('./util/PoweredByUtil'),\n    domEvent = require('min-dom/lib/event');\n\n/**\n * Adds the project logo to the diagram container as\n * required by the bpmn.io license.\n *\n * @see http://bpmn.io/license\n *\n * @param {Element} container\n */\nfunction addProjectLogo(container) {\n  var logoData = PoweredBy.BPMNIO_LOGO;\n\n  var linkMarkup =\n    '<a href=\"http://bpmn.io\" ' +\n       'target=\"_blank\" ' +\n       'class=\"bjs-powered-by\" ' +\n       'title=\"Powered by bpmn.io\" ' +\n       'style=\"position: absolute; bottom: 15px; right: 15px; z-index: 100\">' +\n        '<img src=\"data:image/png;base64,' + logoData + '\">' +\n    '</a>';\n\n  var linkElement = domify(linkMarkup);\n\n  container.appendChild(linkElement);\n\n  domEvent.bind(linkElement, 'click', function(event) {\n    PoweredBy.open();\n\n    event.preventDefault();\n  });\n}\n\n/* </project-logo> */\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/import/Importer.js":"'use strict';\n\nvar BpmnTreeWalker = require('./BpmnTreeWalker');\n\n\n/**\n * Import the definitions into a diagram.\n *\n * Errors and warnings are reported through the specified callback.\n *\n * @param  {Diagram} diagram\n * @param  {ModdleElement} definitions\n * @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done\n */\nfunction importBpmnDiagram(diagram, definitions, done) {\n\n  var importer = diagram.get('bpmnImporter'),\n      eventBus = diagram.get('eventBus'),\n      translate = diagram.get('translate');\n\n  var error,\n      warnings = [];\n\n  /**\n   * Walk the diagram semantically, importing (=drawing)\n   * all elements you encounter.\n   *\n   * @param {ModdleElement} definitions\n   */\n  function render(definitions) {\n\n    var visitor = {\n\n      root: function(element) {\n        return importer.add(element);\n      },\n\n      element: function(element, parentShape) {\n        return importer.add(element, parentShape);\n      },\n\n      error: function(message, context) {\n        warnings.push({ message: message, context: context });\n      }\n    };\n\n    var walker = new BpmnTreeWalker(visitor, translate);\n\n    // traverse BPMN 2.0 document model,\n    // starting at definitions\n    walker.handleDefinitions(definitions);\n  }\n\n  eventBus.fire('import.render.start', { definitions: definitions });\n\n  try {\n    render(definitions);\n  } catch (e) {\n    error = e;\n  }\n\n  eventBus.fire('import.render.complete', {\n    error: error,\n    warnings: warnings\n  });\n\n  done(error, warnings);\n}\n\nmodule.exports.importBpmnDiagram = importBpmnDiagram;","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/import/BpmnTreeWalker.js":"'use strict';\n\nvar filter = require('lodash/collection/filter'),\n    find = require('lodash/collection/find'),\n    forEach = require('lodash/collection/forEach');\n\nvar Refs = require('object-refs');\n\nvar elementToString = require('./Util').elementToString;\n\nvar diRefs = new Refs({ name: 'bpmnElement', enumerable: true }, { name: 'di' });\n\n/**\n * Returns true if an element has the given meta-model type\n *\n * @param  {ModdleElement}  element\n * @param  {String}         type\n *\n * @return {Boolean}\n */\nfunction is(element, type) {\n  return element.$instanceOf(type);\n}\n\n\n/**\n * Find a suitable display candidate for definitions where the DI does not\n * correctly specify one.\n */\nfunction findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function(e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}\n\n\nfunction BpmnTreeWalker(handler, translate) {\n\n  // list of containers already walked\n  var handledElements = {};\n\n  // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n  var deferred = [];\n\n  ///// Helpers /////////////////////////////////\n\n  function contextual(fn, ctx) {\n    return function(e) {\n      fn(e, ctx);\n    };\n  }\n\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n\n  function visit(element, ctx) {\n\n    var gfx = element.gfx;\n\n    // avoid multiple rendering of elements\n    if (gfx) {\n      throw new Error(\n        translate('already rendered {element}', { element: elementToString(element) })\n      );\n    }\n\n    // call handler\n    return handler.element(element, ctx);\n  }\n\n  function visitRoot(element, diagram) {\n    return handler.root(element, diagram);\n  }\n\n  function visitIfDi(element, ctx) {\n\n    try {\n      var gfx = element.di && visit(element, ctx);\n\n      handled(element);\n\n      return gfx;\n    } catch (e) {\n      logError(e.message, { element: element, error: e });\n\n      console.error(translate('failed to import {element}', { element: elementToString(element) }));\n      console.error(e);\n    }\n  }\n\n  function logError(message, context) {\n    handler.error(message, context);\n  }\n\n  ////// DI handling ////////////////////////////\n\n  function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n\n    if (bpmnElement) {\n      if (bpmnElement.di) {\n        logError(\n          translate('multiple DI elements defined for {element}', {\n            element: elementToString(bpmnElement)\n          }),\n          { element: bpmnElement  }\n        );\n      } else {\n        diRefs.bind(bpmnElement, 'di');\n        bpmnElement.di = di;\n      }\n    } else {\n      logError(\n        translate('no bpmnElement referenced in {element}', {\n          element: elementToString(di)\n        }),\n        { element: di }\n      );\n    }\n  }\n\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n\n  function handlePlane(plane) {\n    registerDi(plane);\n\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  }\n\n\n  ////// Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any)\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n  function handleDefinitions(definitions, diagram) {\n    // make sure we walk the correct bpmnElement\n\n    var diagrams = definitions.diagrams;\n\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error(translate('diagram not part of bpmn:Definitions'));\n    }\n\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    }\n\n    // no diagram -> nothing to import\n    if (!diagram) {\n      throw new Error(translate('no diagram to display'));\n    }\n\n    // load DI from selected diagram only\n    handleDiagram(diagram);\n\n\n    var plane = diagram.plane;\n\n    if (!plane) {\n      throw new Error(translate(\n        'no plane for {element}',\n        { element: elementToString(diagram) }\n      ));\n    }\n\n    var rootElement = plane.bpmnElement;\n\n    // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n\n      if (!rootElement) {\n        throw new Error(translate('no process or collaboration to display'));\n      } else {\n\n        logError(\n          translate('correcting missing bpmnElement on {plane} to {rootElement}', {\n            plane: elementToString(plane),\n            rootElement: elementToString(rootElement)\n          })\n        );\n\n        // correct DI on the fly\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n\n\n    var ctx = visitRoot(rootElement, plane);\n\n    if (is(rootElement, 'bpmn:Process')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx);\n\n      // force drawing of everything not yet drawn that is part of the target DI\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(\n        translate('unsupported bpmnElement for {plane}: {rootElement}', {\n          plane: elementToString(plane),\n          rootElement: elementToString(rootElement)\n        })\n      );\n    }\n\n    // handle all deferred elements\n    handleDeferred(deferred);\n  }\n\n  function handleDeferred(deferred) {\n    forEach(deferred, function(d) { d(); });\n  }\n\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n\n    handleArtifacts(process.artifacts, context);\n\n    // log process handled\n    handled(process);\n  }\n\n  function handleUnhandledProcesses(rootElements) {\n\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function(e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n\n    processes.forEach(contextual(handleProcess));\n  }\n\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n\n  function handleArtifact(artifact, context) {\n\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n\n    visitIfDi(artifact, context);\n  }\n\n  function handleArtifacts(artifacts, context) {\n\n    forEach(artifacts, function(e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function() {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n\n  function handleIoSpecification(ioSpecification, context) {\n\n    if (!ioSpecification) {\n      return;\n    }\n\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n\n  function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  }\n\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    }\n\n    // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n    deferred.push(function() {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleBoundaryEvent(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleLane(lane, context) {\n    var newContext = visitIfDi(lane, context);\n\n    if (lane.childLaneSet) {\n      handleLaneSet(lane.childLaneSet, newContext || context);\n    }\n\n    wireFlowNodeRefs(lane);\n  }\n\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n\n  function handleFlowElementsContainer(container, context) {\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n\n    handleFlowElements(container.flowElements, context);\n  }\n\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function(e) {\n      if (is(e, 'bpmn:SequenceFlow')) {\n        deferred.push(function() {\n          handleSequenceFlow(e, context);\n        });\n      } else if (is(e, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function() {\n          handleBoundaryEvent(e, context);\n        });\n      } else if (is(e, 'bpmn:FlowNode')) {\n        handleFlowNode(e, context);\n      } else if (is(e, 'bpmn:DataObject')) {\n        // SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(e, 'bpmn:DataStoreReference')) {\n        handleDataElement(e, context);\n      } else if (is(e, 'bpmn:DataObjectReference')) {\n        handleDataElement(e, context);\n      } else {\n        logError(\n          translate('unrecognized flowElement {element} in context {context}', {\n            element: elementToString(e),\n            context: (context ? elementToString(context.businessObject) : 'null')\n          }),\n          { element: e, context: context }\n        );\n      }\n    });\n  }\n\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n\n    var process = participant.processRef;\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n\n  function handleCollaboration(collaboration) {\n\n    forEach(collaboration.participants, contextual(handleParticipant));\n\n    handleArtifacts(collaboration.artifacts);\n\n    // handle message flows latest in the process\n    deferred.push(function() {\n      handleMessageFlows(collaboration.messageFlows);\n    });\n  }\n\n\n  function wireFlowNodeRefs(lane) {\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function(flowNode) {\n      var lanes = flowNode.get('lanes');\n\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  }\n\n  ///// API ////////////////////////////////\n\n  return {\n    handleDefinitions: handleDefinitions\n  };\n}\n\nmodule.exports = BpmnTreeWalker;","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/import/Util.js":"'use strict';\n\nmodule.exports.elementToString = function(e) {\n  if (!e) {\n    return '<null>';\n  }\n\n  return '<' + e.$type + (e.id ? ' id=\"' + e.id : '') + '\" />';\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/core/index.js":"module.exports = {\n  __depends__: [\n    require('../draw'),\n    require('../import')\n  ]\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/draw/index.js":"module.exports = {\n  __init__: [ 'bpmnRenderer' ],\n  bpmnRenderer: [ 'type', require('./BpmnRenderer') ],\n  pathMap: [ 'type', require('./PathMap') ]\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/draw/BpmnRenderer.js":"'use strict';\n\nvar inherits = require('inherits'),\n    isObject = require('lodash/lang/isObject'),\n    assign = require('lodash/object/assign'),\n    forEach = require('lodash/collection/forEach'),\n    every = require('lodash/collection/every'),\n    some = require('lodash/collection/some');\n\nvar BaseRenderer = require('diagram-js/lib/draw/BaseRenderer'),\n    TextUtil = require('diagram-js/lib/util/Text'),\n    DiUtil = require('../util/DiUtil');\n\nvar getBusinessObject = require('../util/ModelUtil').getBusinessObject,\n    is = require('../util/ModelUtil').is;\n\nvar RenderUtil = require('diagram-js/lib/util/RenderUtil');\n\nvar componentsToPath = RenderUtil.componentsToPath,\n    createLine = RenderUtil.createLine;\n\nvar domQuery = require('min-dom/lib/query');\n\nvar svgAppend = require('tiny-svg/lib/append'),\n    svgAttr = require('tiny-svg/lib/attr'),\n    svgCreate = require('tiny-svg/lib/create'),\n    svgClasses = require('tiny-svg/lib/classes');\n\nvar rotate = require('diagram-js/lib/util/SvgTransformUtil').rotate,\n    transform = require('diagram-js/lib/util/SvgTransformUtil').transform,\n    translate = require('diagram-js/lib/util/SvgTransformUtil').translate;\n\nvar TASK_BORDER_RADIUS = 10;\nvar INNER_OUTER_DIST = 3;\n\nvar LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: 12\n};\n\n\nfunction BpmnRenderer(eventBus, styles, pathMap, canvas, priority) {\n\n  BaseRenderer.call(this, eventBus, priority);\n\n  var textUtil = new TextUtil({\n    style: LABEL_STYLE,\n    size: { width: 100 }\n  });\n\n  var markers = {};\n\n  var computeStyle = styles.computeStyle;\n\n  function addMarker(id, options) {\n    var attrs = assign({\n      fill: 'black',\n      strokeWidth: 1,\n      strokeLinecap: 'round',\n      strokeDasharray: 'none'\n    }, options.attrs);\n\n    var ref = options.ref || { x: 0, y: 0 };\n\n    var scale = options.scale || 1;\n\n    // fix for safari / chrome / firefox bug not correctly\n    // resetting stroke dash array\n    if (attrs.strokeDasharray === 'none') {\n      attrs.strokeDasharray = [10000, 1];\n    }\n\n    var marker = svgCreate('marker');\n\n    svgAttr(options.element, attrs);\n\n    svgAppend(marker, options.element);\n\n    svgAttr(marker, {\n      id: id,\n      viewBox: '0 0 20 20',\n      refX: ref.x,\n      refY: ref.y,\n      markerWidth: 20 * scale,\n      markerHeight: 20 * scale,\n      orient: 'auto'\n    });\n\n    var defs = domQuery('defs', canvas._svg);\n\n    if (!defs) {\n      defs = svgCreate('defs');\n\n      svgAppend(canvas._svg, defs);\n    }\n\n    svgAppend(defs, marker);\n\n    markers[id] = marker;\n  }\n\n  function marker(type, fill, stroke) {\n    var id = type + '-' + fill + '-' + stroke;\n\n    if (!markers[id]) {\n      createMarker(type, fill, stroke);\n    }\n\n    return 'url(#' + id +  ')';\n  }\n\n  function createMarker(type, fill, stroke) {\n    var id = type + '-' + fill + '-' + stroke;\n\n    if (type === 'sequenceflow-end') {\n      var sequenceflowEnd = svgCreate('path');\n      svgAttr(sequenceflowEnd, { d: 'M 1 5 L 11 10 L 1 15 Z' });\n\n      addMarker(id, {\n        element: sequenceflowEnd,\n        ref: { x: 11, y: 10 },\n        scale: 0.5,\n        attrs: {\n          fill: stroke,\n          stroke: stroke\n        }\n      });\n    }\n\n    if (type === 'messageflow-start') {\n      var messageflowStart = svgCreate('circle');\n      svgAttr(messageflowStart, { cx: 6, cy: 6, r: 3.5 });\n\n      addMarker(id, {\n        element: messageflowStart,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: { x: 6, y: 6 }\n      });\n    }\n\n    if (type === 'messageflow-end') {\n      var messageflowEnd = svgCreate('path');\n      svgAttr(messageflowEnd, { d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z' });\n\n      addMarker(id, {\n        element: messageflowEnd,\n        attrs: {\n          fill: fill,\n          stroke: stroke,\n          strokeLinecap: 'butt'\n        },\n        ref: { x: 8.5, y: 5 }\n      });\n    }\n\n    if (type === 'association-start') {\n      var associationStart = svgCreate('path');\n      svgAttr(associationStart, { d: 'M 11 5 L 1 10 L 11 15' });\n\n      addMarker(id, {\n        element: associationStart,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: { x: 1, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'association-end') {\n      var associationEnd = svgCreate('path');\n      svgAttr(associationEnd, { d: 'M 1 5 L 11 10 L 1 15' });\n\n      addMarker(id, {\n        element: associationEnd,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: { x: 12, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'conditional-flow-marker') {\n      var conditionalflowMarker = svgCreate('path');\n      svgAttr(conditionalflowMarker, { d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z' });\n\n      addMarker(id, {\n        element: conditionalflowMarker,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: { x: -1, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'conditional-default-flow-marker') {\n      var conditionaldefaultflowMarker = svgCreate('path');\n      svgAttr(conditionaldefaultflowMarker, { d: 'M 6 4 L 10 16' });\n\n      addMarker(id, {\n        element: conditionaldefaultflowMarker,\n        attrs: {\n          stroke: stroke\n        },\n        ref: { x: 0, y: 10 },\n        scale: 0.5\n      });\n    }\n  }\n\n  function drawCircle(parentGfx, width, height, offset, attrs) {\n\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n\n    offset = offset || 0;\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var cx = width / 2,\n        cy = height / 2;\n\n    var circle = svgCreate('circle');\n    svgAttr(circle, {\n      cx: cx,\n      cy: cy,\n      r: Math.round((width + height) / 4 - offset)\n    });\n    svgAttr(circle, attrs);\n\n    svgAppend(parentGfx, circle);\n\n    return circle;\n  }\n\n  function drawRect(parentGfx, width, height, r, offset, attrs) {\n\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n\n    offset = offset || 0;\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var rect = svgCreate('rect');\n    svgAttr(rect, {\n      x: offset,\n      y: offset,\n      width: width - offset * 2,\n      height: height - offset * 2,\n      rx: r,\n      ry: r\n    });\n    svgAttr(rect, attrs);\n\n    svgAppend(parentGfx, rect);\n\n    return rect;\n  }\n\n  function drawDiamond(parentGfx, width, height, attrs) {\n\n    var x_2 = width / 2;\n    var y_2 = height / 2;\n\n    var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];\n\n    var pointsString = points.map(function(point) {\n      return point.x + ',' + point.y;\n    }).join(' ');\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var polygon = svgCreate('polygon');\n    svgAttr(polygon, {\n      points: pointsString\n    });\n    svgAttr(polygon, attrs);\n\n    svgAppend(parentGfx, polygon);\n\n    return polygon;\n  }\n\n  function drawLine(parentGfx, waypoints, attrs) {\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'none'\n    });\n\n    var line = createLine(waypoints, attrs);\n\n    svgAppend(parentGfx, line);\n\n    return line;\n  }\n\n  function drawPath(parentGfx, d, attrs) {\n\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\n      strokeWidth: 2,\n      stroke: 'black'\n    });\n\n    var path = svgCreate('path');\n    svgAttr(path, { d: d });\n    svgAttr(path, attrs);\n\n    svgAppend(parentGfx, path);\n\n    return path;\n  }\n\n  function drawMarker(type, parentGfx, path, attrs) {\n    return drawPath(parentGfx, path, assign({ 'data-marker': type }, attrs));\n  }\n\n  function as(type) {\n    return function(parentGfx, element) {\n      return handlers[type](parentGfx, element);\n    };\n  }\n\n  function renderer(type) {\n    return handlers[type];\n  }\n\n  function renderEventContent(element, parentGfx) {\n\n    var event = getSemantic(element);\n    var isThrowing = isThrowEvent(event);\n\n    if (isTypedEvent(event, 'bpmn:MessageEventDefinition')) {\n      return renderer('bpmn:MessageEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:TimerEventDefinition')) {\n      return renderer('bpmn:TimerEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:ConditionalEventDefinition')) {\n      return renderer('bpmn:ConditionalEventDefinition')(parentGfx, element);\n    }\n\n    if (isTypedEvent(event, 'bpmn:SignalEventDefinition')) {\n      return renderer('bpmn:SignalEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&\n      isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: false })) {\n      return renderer('bpmn:MultipleEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&\n      isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: true })) {\n      return renderer('bpmn:ParallelMultipleEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:EscalationEventDefinition')) {\n      return renderer('bpmn:EscalationEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:LinkEventDefinition')) {\n      return renderer('bpmn:LinkEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:ErrorEventDefinition')) {\n      return renderer('bpmn:ErrorEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition')) {\n      return renderer('bpmn:CancelEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CompensateEventDefinition')) {\n      return renderer('bpmn:CompensateEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:TerminateEventDefinition')) {\n      return renderer('bpmn:TerminateEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    return null;\n  }\n\n  function renderLabel(parentGfx, label, options) {\n    var text = textUtil.createText(label || '', options);\n    svgClasses(text).add('djs-label');\n    svgAppend(parentGfx, text);\n\n    return text;\n  }\n\n  function renderEmbeddedLabel(parentGfx, element, align) {\n    var semantic = getSemantic(element);\n\n    return renderLabel(parentGfx, semantic.name, {\n      box: element,\n      align: align,\n      padding: 5,\n      style: {\n        fill: getStrokeColor(element)\n      }\n    });\n  }\n\n  function renderExternalLabel(parentGfx, element) {\n    var semantic = getSemantic(element);\n    var box = {\n      width: 90,\n      height: 30,\n      x: element.width / 2 + element.x,\n      y: element.height / 2 + element.y\n    };\n\n    return renderLabel(parentGfx, semantic.name, {\n      box: box,\n      fitBox: true,\n      style: { fontSize: '11px' }\n    });\n  }\n\n  function renderLaneLabel(parentGfx, text, element) {\n    var textBox = renderLabel(parentGfx, text, {\n      box: { height: 30, width: element.height },\n      align: 'center-middle',\n      style: {\n        fill: getStrokeColor(element)\n      }\n    });\n\n    var top = -1 * element.height;\n\n    transform(textBox, 0, -top, 270);\n  }\n\n  function createPathFromConnection(connection) {\n    var waypoints = connection.waypoints;\n\n    var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;\n    for (var i = 1; i < waypoints.length; i++) {\n      pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';\n    }\n    return pathData;\n  }\n\n  var handlers = this.handlers = {\n    'bpmn:Event': function(parentGfx, element, attrs) {\n      return drawCircle(parentGfx, element.width, element.height, attrs);\n    },\n    'bpmn:StartEvent': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var semantic = getSemantic(element);\n\n      if (!semantic.isInterrupting) {\n        attrs = {\n          strokeDasharray: '6',\n          strokeLinecap: 'round'\n        };\n      }\n\n      var circle = renderer('bpmn:Event')(parentGfx, element, attrs);\n\n      renderEventContent(element, parentGfx);\n\n      return circle;\n    },\n    'bpmn:MessageEventDefinition': function(parentGfx, element, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.235,\n          my: 0.315\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(element) : getFillColor(element);\n      var stroke = isThrowing ? getFillColor(element) : getStrokeColor(element);\n\n      var messagePath = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: stroke\n      });\n\n      return messagePath;\n    },\n    'bpmn:TimerEventDefinition': function(parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {\n        strokeWidth: 2,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {\n        xScaleFactor: 0.75,\n        yScaleFactor: 0.75,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.5,\n          my: 0.5\n        }\n      });\n\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 2,\n        strokeLinecap: 'square',\n        stroke: getStrokeColor(element)\n      });\n\n      for (var i = 0;i < 12;i++) {\n\n        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {\n          xScaleFactor: 0.75,\n          yScaleFactor: 0.75,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.5,\n            my: 0.5\n          }\n        });\n\n        var width = element.width / 2;\n        var height = element.height / 2;\n\n        drawPath(parentGfx, linePathData, {\n          strokeWidth: 1,\n          strokeLinecap: 'square',\n          transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')',\n          stroke: getStrokeColor(element)\n        });\n      }\n\n      return circle;\n    },\n    'bpmn:EscalationEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:ConditionalEventDefinition': function(parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.222\n        }\n      });\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:LinkEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_LINK', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.57,\n          my: 0.263\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:ErrorEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ERROR', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.2,\n          my: 0.722\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:CancelEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {\n        xScaleFactor: 1.0,\n        yScaleFactor: 1.0,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.638,\n          my: -0.055\n        }\n      });\n\n      var fill = isThrowing ? 'black' : 'none';\n\n      var path = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill\n      });\n\n      rotate(path, 45);\n\n      return path;\n    },\n    'bpmn:CompensateEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.22,\n          my: 0.5\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:SignalEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:MultipleEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.222,\n          my: 0.36\n        }\n      });\n\n      var fill = isThrowing ? 'black' : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill\n      });\n    },\n    'bpmn:ParallelMultipleEventDefinition': function(parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {\n        xScaleFactor: 1.2,\n        yScaleFactor: 1.2,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.458,\n          my: 0.194\n        }\n      });\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(event),\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:EndEvent': function(parentGfx, element) {\n      var circle = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 4,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      renderEventContent(element, parentGfx, true);\n\n      return circle;\n    },\n    'bpmn:TerminateEventDefinition': function(parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 8, {\n        strokeWidth: 4,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return circle;\n    },\n    'bpmn:IntermediateEvent': function(parentGfx, element) {\n      var outer = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      /* inner */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {\n        strokeWidth: 1,\n        fill: getFillColor(element, 'none'),\n        stroke: getStrokeColor(element)\n      });\n\n      renderEventContent(element, parentGfx);\n\n      return outer;\n    },\n    'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),\n    'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),\n\n    'bpmn:Activity': function(parentGfx, element, attrs) {\n      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);\n    },\n\n    'bpmn:Task': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n\n      renderEmbeddedLabel(parentGfx, element, 'center-middle');\n      attachTaskMarkers(parentGfx, element);\n\n      return rect;\n    },\n    'bpmn:ServiceTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 12,\n          y: 18\n        }\n      });\n\n      /* service bg */ drawPath(parentGfx, pathDataBG, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {\n        abspos: {\n          x: 17.2,\n          y: 18\n        }\n      });\n\n      /* service fill */ drawPath(parentGfx, fillPathData, {\n        strokeWidth: 0,\n        fill: getFillColor(element)\n      });\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 17,\n          y: 22\n        }\n      });\n\n      /* service */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:UserTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var x = 15;\n      var y = 12;\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user2 path */ drawPath(parentGfx, pathData2, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user3 path */ drawPath(parentGfx, pathData3, {\n        strokeWidth: 0.5,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:ManualTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {\n        abspos: {\n          x: 17,\n          y: 15\n        }\n      });\n\n      /* manual path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5, // 0.25,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:SendTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: 21,\n        containerHeight: 14,\n        position: {\n          mx: 0.285,\n          my: 0.357\n        }\n      });\n\n      /* send path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element),\n        stroke: getFillColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:ReceiveTask' : function(parentGfx, element) {\n      var semantic = getSemantic(element);\n\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathData;\n\n      if (semantic.instantiate) {\n        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });\n\n        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {\n          abspos: {\n            x: 7.77,\n            y: 9.52\n          }\n        });\n      } else {\n\n        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n          xScaleFactor: 0.9,\n          yScaleFactor: 0.9,\n          containerWidth: 21,\n          containerHeight: 14,\n          position: {\n            mx: 0.3,\n            my: 0.4\n          }\n        });\n      }\n\n      /* receive path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:ScriptTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {\n        abspos: {\n          x: 15,\n          y: 20\n        }\n      });\n\n      /* script path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:BusinessRuleTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n\n      var businessHeaderPath = drawPath(parentGfx, headerPathData);\n      svgAttr(businessHeaderPath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, '#aaaaaa'),\n        stroke: getStrokeColor(element)\n      });\n\n      var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n\n      var businessPath = drawPath(parentGfx, headerData);\n      svgAttr(businessPath, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:SubProcess': function(parentGfx, element, attrs) {\n      attrs = assign({\n        fillOpacity: 0.95,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      }, attrs);\n\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n\n      var expanded = DiUtil.isExpanded(element);\n\n      var isEventSubProcess = DiUtil.isEventSubProcess(element);\n\n      if (isEventSubProcess) {\n        svgAttr(rect, {\n          strokeDasharray: '1,2'\n        });\n      }\n\n      renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle');\n\n      if (expanded) {\n        attachTaskMarkers(parentGfx, element);\n      } else {\n        attachTaskMarkers(parentGfx, element, ['SubProcessMarker']);\n      }\n\n      return rect;\n    },\n    'bpmn:AdHocSubProcess': function(parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element);\n    },\n    'bpmn:Transaction': function(parentGfx, element) {\n      var outer = renderer('bpmn:SubProcess')(parentGfx, element);\n\n      var innerAttrs = styles.style([ 'no-fill', 'no-events' ], {\n        stroke: getStrokeColor(element)\n      });\n\n      /* inner path */ drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);\n\n      return outer;\n    },\n    'bpmn:CallActivity': function(parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element, {\n        strokeWidth: 5\n      });\n    },\n    'bpmn:Participant': function(parentGfx, element) {\n\n      var attrs = {\n        fillOpacity: 0.95,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var lane = renderer('bpmn:Lane')(parentGfx, element, attrs);\n\n      var expandedPool = DiUtil.isExpanded(element);\n\n      if (expandedPool) {\n        drawLine(parentGfx, [\n          { x: 30, y: 0 },\n          { x: 30, y: element.height }\n        ], {\n          stroke: getStrokeColor(element)\n        });\n        var text = getSemantic(element).name;\n        renderLaneLabel(parentGfx, text, element);\n      } else {\n        // Collapsed pool draw text inline\n        var text2 = getSemantic(element).name;\n        renderLabel(parentGfx, text2, {\n          box: element, align: 'center-middle',\n          style: {\n            fill: getStrokeColor(element)\n          }\n        });\n      }\n\n      var participantMultiplicity = !!(getSemantic(element).participantMultiplicity);\n\n      if (participantMultiplicity) {\n        renderer('ParticipantMultiplicityMarker')(parentGfx, element);\n      }\n\n      return lane;\n    },\n    'bpmn:Lane': function(parentGfx, element, attrs) {\n      var rect = drawRect(parentGfx, element.width, element.height, 0, assign({\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      }, attrs));\n\n      var semantic = getSemantic(element);\n\n      if (semantic.$type === 'bpmn:Lane') {\n        var text = semantic.name;\n        renderLaneLabel(parentGfx, text, element);\n      }\n\n      return rect;\n    },\n    'bpmn:InclusiveGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      /* circle path */\n      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {\n        strokeWidth: 2.5,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return diamond;\n    },\n    'bpmn:ExclusiveGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {\n        xScaleFactor: 0.4,\n        yScaleFactor: 0.4,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.32,\n          my: 0.3\n        }\n      });\n\n      if ((getDi(element).isMarkerVisible)) {\n        drawPath(parentGfx, pathData, {\n          strokeWidth: 1,\n          fill: getStrokeColor(element),\n          stroke: getStrokeColor(element)\n        });\n      }\n\n      return diamond;\n    },\n    'bpmn:ComplexGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {\n        xScaleFactor: 0.5,\n        yScaleFactor:0.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.26\n        }\n      });\n\n      /* complex path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return diamond;\n    },\n    'bpmn:ParallelGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n        xScaleFactor: 0.6,\n        yScaleFactor:0.6,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.2\n        }\n      });\n\n      /* parallel path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return diamond;\n    },\n    'bpmn:EventBasedGateway': function(parentGfx, element) {\n\n      var semantic = getSemantic(element);\n\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      /* outer circle path */ drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {\n        strokeWidth: 1,\n        fill: 'none',\n        stroke: getStrokeColor(element)\n      });\n\n      var type = semantic.eventGatewayType;\n      var instantiate = !!semantic.instantiate;\n\n      function drawEvent() {\n\n        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {\n          xScaleFactor: 0.18,\n          yScaleFactor: 0.18,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.36,\n            my: 0.44\n          }\n        });\n\n        var attrs = {\n          strokeWidth: 2,\n          fill: getFillColor(element, 'none'),\n          stroke: getStrokeColor(element)\n        };\n\n        /* event path */ drawPath(parentGfx, pathData, attrs);\n      }\n\n      if (type === 'Parallel') {\n\n        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n          xScaleFactor: 0.4,\n          yScaleFactor:0.4,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.474,\n            my: 0.296\n          }\n        });\n\n        var parallelPath = drawPath(parentGfx, pathData);\n        svgAttr(parallelPath, {\n          strokeWidth: 1,\n          fill: 'none'\n        });\n      } else if (type === 'Exclusive') {\n\n        if (!instantiate) {\n          var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);\n          svgAttr(innerCircle, {\n            strokeWidth: 1,\n            fill: 'none',\n            stroke: getStrokeColor(element)\n          });\n        }\n\n        drawEvent();\n      }\n\n\n      return diamond;\n    },\n    'bpmn:Gateway': function(parentGfx, element) {\n      return drawDiamond(parentGfx, element.width, element.height);\n    },\n    'bpmn:SequenceFlow': function(parentGfx, element) {\n      var pathData = createPathFromConnection(element);\n\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      var attrs = {\n        strokeLinejoin: 'round',\n        markerEnd: marker('sequenceflow-end', fill, stroke),\n        stroke: getStrokeColor(element)\n      };\n\n      var path = drawPath(parentGfx, pathData, attrs);\n\n      var sequenceFlow = getSemantic(element);\n      var source = element.source.businessObject;\n\n      // conditional flow marker\n      if (sequenceFlow.conditionExpression && source.$instanceOf('bpmn:Activity')) {\n        svgAttr(path, {\n          markerStart: marker('conditional-flow-marker', fill, stroke)\n        });\n      }\n\n      // default marker\n      if (source.default && (source.$instanceOf('bpmn:Gateway') || source.$instanceOf('bpmn:Activity')) &&\n          source.default === sequenceFlow) {\n        svgAttr(path, {\n          markerStart: marker('conditional-default-flow-marker', fill, stroke)\n        });\n      }\n\n      return path;\n    },\n    'bpmn:Association': function(parentGfx, element, attrs) {\n\n      var semantic = getSemantic(element);\n\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      attrs = assign({\n        strokeDasharray: '0.5, 5',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        stroke: getStrokeColor(element)\n      }, attrs || {});\n\n      if (semantic.associationDirection === 'One' ||\n          semantic.associationDirection === 'Both') {\n        attrs.markerEnd = marker('association-end', fill, stroke);\n      }\n\n      if (semantic.associationDirection === 'Both') {\n        attrs.markerStart = marker('association-start', fill, stroke);\n      }\n\n      return drawLine(parentGfx, element.waypoints, attrs);\n    },\n    'bpmn:DataInputAssociation': function(parentGfx, element) {\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:DataOutputAssociation': function(parentGfx, element) {\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:MessageFlow': function(parentGfx, element) {\n\n      var semantic = getSemantic(element),\n          di = getDi(element);\n\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      var pathData = createPathFromConnection(element);\n\n      var attrs = {\n        markerEnd: marker('messageflow-end', fill, stroke),\n        markerStart: marker('messageflow-start', fill, stroke),\n        strokeDasharray: '10, 12',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        strokeWidth: '1.5px',\n        stroke: getStrokeColor(element)\n      };\n\n      var path = drawPath(parentGfx, pathData, attrs);\n\n      if (semantic.messageRef) {\n        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);\n\n        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {\n          abspos: {\n            x: midPoint.x,\n            y: midPoint.y\n          }\n        });\n\n        var messageAttrs = { strokeWidth: 1 };\n\n        if (di.messageVisibleKind === 'initiating') {\n          messageAttrs.fill = 'white';\n          messageAttrs.stroke = 'black';\n        } else {\n          messageAttrs.fill = '#888';\n          messageAttrs.stroke = 'white';\n        }\n\n        drawPath(parentGfx, markerPathData, messageAttrs);\n      }\n\n      return path;\n    },\n    'bpmn:DataObject': function(parentGfx, element) {\n      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.474,\n          my: 0.296\n        }\n      });\n\n      var elementObject = drawPath(parentGfx, pathData, {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var semantic = getSemantic(element);\n\n      if (isCollection(semantic)) {\n        renderDataItemCollection(parentGfx, element);\n      }\n\n      return elementObject;\n    },\n    'bpmn:DataObjectReference': as('bpmn:DataObject'),\n    'bpmn:DataInput': function(parentGfx, element) {\n\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* input arrow path */ drawPath(parentGfx, arrowPathData, { strokeWidth: 1 });\n\n      return elementObject;\n    },\n    'bpmn:DataOutput': function(parentGfx, element) {\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* output arrow path */ drawPath(parentGfx, arrowPathData, {\n        strokeWidth: 1,\n        fill: 'black'\n      });\n\n      return elementObject;\n    },\n    'bpmn:DataStoreReference': function(parentGfx, element) {\n      var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0,\n          my: 0.133\n        }\n      });\n\n      var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {\n        strokeWidth: 2,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return elementStore;\n    },\n    'bpmn:BoundaryEvent': function(parentGfx, element) {\n\n      var semantic = getSemantic(element),\n          cancel = semantic.cancelActivity;\n\n      var attrs = {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      if (!cancel) {\n        attrs.strokeDasharray = '6';\n        attrs.strokeLinecap = 'round';\n      }\n\n      var outer = renderer('bpmn:Event')(parentGfx, element, attrs);\n      /* inner path */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, assign(attrs, { fill: 'none' }));\n\n      renderEventContent(element, parentGfx);\n\n      return outer;\n    },\n    'bpmn:Group': function(parentGfx, element) {\n      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {\n        strokeWidth: 1,\n        strokeDasharray: '8,3,1,3',\n        fill: 'none',\n        pointerEvents: 'none'\n      });\n    },\n    'label': function(parentGfx, element) {\n      return renderExternalLabel(parentGfx, element);\n    },\n    'bpmn:TextAnnotation': function(parentGfx, element) {\n      var style = {\n        'fill': 'none',\n        'stroke': 'none'\n      };\n\n      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);\n\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n      drawPath(parentGfx, textPathData, {\n        stroke: getStrokeColor(element)\n      });\n\n      var text = getSemantic(element).text || '';\n      renderLabel(parentGfx, text, { box: element, align: 'left-middle', padding: 5 });\n\n      return textElement;\n    },\n    'ParticipantMultiplicityMarker': function(parentGfx, element) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2) / element.width),\n          my: (element.height - 15) / element.height\n        }\n      });\n\n      drawMarker('participant-multiplicity', parentGfx, markerPath);\n    },\n    'SubProcessMarker': function(parentGfx, element) {\n      var markerRect = drawRect(parentGfx, 14, 14, 0, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      // Process marker is placed in the middle of the box\n      // therefore fixed values can be used here\n      translate(markerRect, element.width / 2 - 7.5, element.height - 20);\n\n      var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {\n        xScaleFactor: 1.5,\n        yScaleFactor: 1.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 - 7.5) / element.width,\n          my: (element.height - 20) / element.height\n        }\n      });\n\n      drawMarker('sub-process', parentGfx, markerPath, {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n    },\n    'ParallelMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.parallel) / element.width),\n          my: (element.height - 20) / element.height\n        }\n      });\n\n      drawMarker('parallel', parentGfx, markerPath);\n    },\n    'SequentialMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.seq) / element.width),\n          my: (element.height - 19) / element.height\n        }\n      });\n\n      drawMarker('sequential', parentGfx, markerPath);\n    },\n    'CompensationMarker': function(parentGfx, element, position) {\n      var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.compensation) / element.width),\n          my: (element.height - 13) / element.height\n        }\n      });\n\n      drawMarker('compensation', parentGfx, markerMath, { strokeWidth: 1 });\n    },\n    'LoopMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_LOOP', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.loop) / element.width),\n          my: (element.height - 7) / element.height\n        }\n      });\n\n      drawMarker('loop', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: 'none',\n        strokeLinecap: 'round',\n        strokeMiterlimit: 0.5\n      });\n    },\n    'AdhocMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.adhoc) / element.width),\n          my: (element.height - 15) / element.height\n        }\n      });\n\n      drawMarker('adhoc', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: 'black'\n      });\n    }\n  };\n\n  function attachTaskMarkers(parentGfx, element, taskMarkers) {\n    var obj = getSemantic(element);\n\n    var subprocess = taskMarkers && taskMarkers.indexOf('SubProcessMarker') !== -1;\n    var position;\n\n    if (subprocess) {\n      position = {\n        seq: -21,\n        parallel: -22,\n        compensation: -42,\n        loop: -18,\n        adhoc: 10\n      };\n    } else {\n      position = {\n        seq: -3,\n        parallel: -6,\n        compensation: -27,\n        loop: 0,\n        adhoc: 10\n      };\n    }\n\n    forEach(taskMarkers, function(marker) {\n      renderer(marker)(parentGfx, element, position);\n    });\n\n    if (obj.isForCompensation) {\n      renderer('CompensationMarker')(parentGfx, element, position);\n    }\n\n    if (obj.$type === 'bpmn:AdHocSubProcess') {\n      renderer('AdhocMarker')(parentGfx, element, position);\n    }\n\n    var loopCharacteristics = obj.loopCharacteristics,\n        isSequential = loopCharacteristics && loopCharacteristics.isSequential;\n\n    if (loopCharacteristics) {\n\n      if (isSequential === undefined) {\n        renderer('LoopMarker')(parentGfx, element, position);\n      }\n\n      if (isSequential === false) {\n        renderer('ParallelMarker')(parentGfx, element, position);\n      }\n\n      if (isSequential === true) {\n        renderer('SequentialMarker')(parentGfx, element, position);\n      }\n    }\n  }\n\n  function renderDataItemCollection(parentGfx, element) {\n\n    var yPosition = (element.height - 16) / element.height;\n\n    var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {\n      xScaleFactor: 1,\n      yScaleFactor: 1,\n      containerWidth: element.width,\n      containerHeight: element.height,\n      position: {\n        mx: 0.451,\n        my: yPosition\n      }\n    });\n\n    /* collection path */ drawPath(parentGfx, pathData, {\n      strokeWidth: 2\n    });\n  }\n}\n\n\ninherits(BpmnRenderer, BaseRenderer);\n\nBpmnRenderer.$inject = [ 'eventBus', 'styles', 'pathMap', 'canvas' ];\n\nmodule.exports = BpmnRenderer;\n\n\nBpmnRenderer.prototype.canRender = function(element) {\n  return is(element, 'bpmn:BaseElement');\n};\n\nBpmnRenderer.prototype.drawShape = function(parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};\n\nBpmnRenderer.prototype.drawConnection = function(parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};\n\nBpmnRenderer.prototype.getShapePath = function(element) {\n\n  if (is(element, 'bpmn:Event')) {\n    return getCirclePath(element);\n  }\n\n  if (is(element, 'bpmn:Activity')) {\n    return getRoundRectPath(element, TASK_BORDER_RADIUS);\n  }\n\n  if (is(element, 'bpmn:Gateway')) {\n    return getDiamondPath(element);\n  }\n\n  return getRectPath(element);\n};\n\n\n///////// helper functions /////////////////////////////\n\n/**\n * Checks if eventDefinition of the given element matches with semantic type.\n *\n * @return {boolean} true if element is of the given semantic type\n */\nfunction isTypedEvent(event, eventDefinitionType, filter) {\n\n  function matches(definition, filter) {\n    return every(filter, function(val, key) {\n\n      // we want a == conversion here, to be able to catch\n      // undefined == false and friends\n      /* jshint -W116 */\n      return definition[key] == val;\n    });\n  }\n\n  return some(event.eventDefinitions, function(definition) {\n    return definition.$type === eventDefinitionType && matches(event, filter);\n  });\n}\n\nfunction isThrowEvent(event) {\n  return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');\n}\n\nfunction isCollection(element) {\n  var dataObject = element.dataObjectRef;\n\n  return element.isCollection || (dataObject && dataObject.isCollection);\n}\n\nfunction getDi(element) {\n  return element.businessObject.di;\n}\n\nfunction getSemantic(element) {\n  return element.businessObject;\n}\n\n\n\n/////// cropping path customizations /////////////////////////\n\nfunction getCirclePath(shape) {\n\n  var cx = shape.x + shape.width / 2,\n      cy = shape.y + shape.height / 2,\n      radius = shape.width / 2;\n\n  var circlePath = [\n    ['M', cx, cy],\n    ['m', 0, -radius],\n    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],\n    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],\n    ['z']\n  ];\n\n  return componentsToPath(circlePath);\n}\n\nfunction getRoundRectPath(shape, borderRadius) {\n\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var roundRectPath = [\n    ['M', x + borderRadius, y],\n    ['l', width - borderRadius * 2, 0],\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],\n    ['l', 0, height - borderRadius * 2],\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],\n    ['l', borderRadius * 2 - width, 0],\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],\n    ['l', 0, borderRadius * 2 - height],\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],\n    ['z']\n  ];\n\n  return componentsToPath(roundRectPath);\n}\n\nfunction getDiamondPath(shape) {\n\n  var width = shape.width,\n      height = shape.height,\n      x = shape.x,\n      y = shape.y,\n      halfWidth = width / 2,\n      halfHeight = height / 2;\n\n  var diamondPath = [\n    ['M', x + halfWidth, y],\n    ['l', halfWidth, halfHeight],\n    ['l', -halfWidth, halfHeight],\n    ['l', -halfWidth, -halfHeight],\n    ['z']\n  ];\n\n  return componentsToPath(diamondPath);\n}\n\nfunction getRectPath(shape) {\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var rectPath = [\n    ['M', x, y],\n    ['l', width, 0],\n    ['l', 0, height],\n    ['l', -width, 0],\n    ['z']\n  ];\n\n  return componentsToPath(rectPath);\n}\n\nfunction getFillColor(element, defaultColor) {\n  var bo = getBusinessObject(element);\n\n  return bo.di.get('fill') || defaultColor || 'white';\n}\n\nfunction getStrokeColor(element, defaultColor) {\n  var bo = getBusinessObject(element);\n\n  return bo.di.get('stroke') || defaultColor || 'black';\n}\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/util/DiUtil.js":"'use strict';\n\nvar is = require('./ModelUtil').is,\n    getBusinessObject = require('./ModelUtil').getBusinessObject;\n\nvar forEach = require('lodash/collection/forEach');\n\nmodule.exports.isExpanded = function(element) {\n\n  if (is(element, 'bpmn:CallActivity')) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:SubProcess')) {\n    return !!getBusinessObject(element).di.isExpanded;\n  }\n\n  if (is(element, 'bpmn:Participant')) {\n    return !!getBusinessObject(element).processRef;\n  }\n\n  return true;\n};\n\nmodule.exports.isInterrupting = function(element) {\n  return element && getBusinessObject(element).isInterrupting !== false;\n};\n\nmodule.exports.isEventSubProcess = function(element) {\n  return element && !!getBusinessObject(element).triggeredByEvent;\n};\n\nfunction hasEventDefinition(element, eventType) {\n  var bo = getBusinessObject(element),\n      hasEventDefinition = false;\n\n  if (bo.eventDefinitions) {\n    forEach(bo.eventDefinitions, function(event) {\n      if (is(event, eventType)) {\n        hasEventDefinition = true;\n      }\n    });\n  }\n\n  return hasEventDefinition;\n}\n\nmodule.exports.hasEventDefinition = hasEventDefinition;\n\nmodule.exports.hasErrorEventDefinition = function(element) {\n  return hasEventDefinition(element, 'bpmn:ErrorEventDefinition');\n};\n\nmodule.exports.hasEscalationEventDefinition = function(element) {\n  return hasEventDefinition(element, 'bpmn:EscalationEventDefinition');\n};\n\nmodule.exports.hasCompensateEventDefinition = function(element) {\n  return hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/util/ModelUtil.js":"'use strict';\n\n/**\n * Is an element of the given BPMN type?\n *\n * @param  {djs.model.Base|ModdleElement} element\n * @param  {String} type\n *\n * @return {Boolean}\n */\nfunction is(element, type) {\n  var bo = getBusinessObject(element);\n\n  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);\n}\n\nmodule.exports.is = is;\n\n\n/**\n * Return the business object for a given element.\n *\n * @param  {djs.model.Base|ModdleElement} element\n *\n * @return {ModdleElement}\n */\nfunction getBusinessObject(element) {\n  return (element && element.businessObject) || element;\n}\n\nmodule.exports.getBusinessObject = getBusinessObject;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/draw/PathMap.js":"'use strict';\n\n/**\n * Map containing SVG paths needed by BpmnRenderer.\n */\n\nfunction PathMap() {\n\n  /**\n   * Contains a map of path elements\n   *\n   * <h1>Path definition</h1>\n   * A parameterized path is defined like this:\n   * <pre>\n   * 'GATEWAY_PARALLEL': {\n   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\n          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\n   *   height: 17.5,\n   *   width:  17.5,\n   *   heightElements: [2.5, 7.5],\n   *   widthElements: [2.5, 7.5]\n   * }\n   * </pre>\n   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling\n   * is based on the ratio between the specified height and width in this object and the\n   * height and width that is set as scale target (Note x,y coordinates will be scaled with\n   * individual ratios).</p>\n   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.\n   * The scaling is based on the computed ratios.\n   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using\n   * the computed ratio coefficient.\n   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.\n   *   <ul>\n   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>\n   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>\n   *   </ul>\n   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.\n   * </p>\n   */\n  this.pathMap = {\n    'EVENT_MESSAGE': {\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\n      height: 36,\n      width:  36,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'EVENT_SIGNAL': {\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',\n      height: 36,\n      width: 36,\n      heightElements: [18],\n      widthElements: [10, 20]\n    },\n    'EVENT_ESCALATION': {\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',\n      height: 36,\n      width: 36,\n      heightElements: [20, 7],\n      widthElements: [8]\n    },\n    'EVENT_CONDITIONAL': {\n      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +\n         'M {e.x2},{e.y3} l {e.x0},0 ' +\n         'M {e.x2},{e.y4} l {e.x0},0 ' +\n         'M {e.x2},{e.y5} l {e.x0},0 ' +\n         'M {e.x2},{e.y6} l {e.x0},0 ' +\n         'M {e.x2},{e.y7} l {e.x0},0 ' +\n         'M {e.x2},{e.y8} l {e.x0},0 ',\n      height: 36,\n      width:  36,\n      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],\n      widthElements:  [10.5, 14.5, 12.5]\n    },\n    'EVENT_LINK': {\n      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',\n      height: 36,\n      width: 36,\n      heightElements: [4.4375, 6.75, 7.8125],\n      widthElements: [9.84375, 13.5]\n    },\n    'EVENT_ERROR': {\n      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',\n      height: 36,\n      width: 36,\n      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],\n      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]\n    },\n    'EVENT_CANCEL_45': {\n      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\n      height: 36,\n      width: 36,\n      heightElements: [4.75, 8.5],\n      widthElements: [4.75, 8.5]\n    },\n    'EVENT_COMPENSATION': {\n      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',\n      height: 36,\n      width: 36,\n      heightElements: [6.5, 13, 0.4, 6.1],\n      widthElements: [9, 9.3, 8.7]\n    },\n    'EVENT_TIMER_WH': {\n      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',\n      height: 36,\n      width:  36,\n      heightElements: [10, 2],\n      widthElements: [3, 7]\n    },\n    'EVENT_TIMER_LINE': {\n      d:  'M {mx},{my} ' +\n          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',\n      height: 36,\n      width:  36,\n      heightElements: [10, 3],\n      widthElements: [0, 0]\n    },\n    'EVENT_MULTIPLE': {\n      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',\n      height: 36,\n      width:  36,\n      heightElements: [6.28099, 12.56199],\n      widthElements: [3.1405, 9.42149, 12.56198]\n    },\n    'EVENT_PARALLEL_MULTIPLE': {\n      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\n        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\n      height: 36,\n      width:  36,\n      heightElements: [2.56228, 7.68683],\n      widthElements: [2.56228, 7.68683]\n    },\n    'GATEWAY_EXCLUSIVE': {\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +\n                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +\n                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',\n      height: 17.5,\n      width:  17.5,\n      heightElements: [8.5, 6.5312, -6.5312, -8.5],\n      widthElements:  [6.5, -6.5, 3, -3, 5, -5]\n    },\n    'GATEWAY_PARALLEL': {\n      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\n      height: 30,\n      width:  30,\n      heightElements: [5, 12.5],\n      widthElements: [5, 12.5]\n    },\n    'GATEWAY_EVENT_BASED': {\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',\n      height: 11,\n      width:  11,\n      heightElements: [-6, 6, 12, -12],\n      widthElements: [9, -3, -12]\n    },\n    'GATEWAY_COMPLEX': {\n      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +\n        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +\n        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +\n        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',\n      height: 17.125,\n      width:  17.125,\n      heightElements: [4.875, 3.4375, 2.125, 3],\n      widthElements: [3.4375, 2.125, 4.875, 3]\n    },\n    'DATA_OBJECT_PATH': {\n      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',\n      height: 61,\n      width:  51,\n      heightElements: [10, 50, 60],\n      widthElements: [10, 40, 50, 60]\n    },\n    'DATA_OBJECT_COLLECTION_PATH': {\n      d:'m {mx}, {my} ' +\n        'm  0 15  l 0 -15 ' +\n        'm  4 15  l 0 -15 ' +\n        'm  4 15  l 0 -15 ',\n      height: 61,\n      width:  51,\n      heightElements: [12],\n      widthElements: [1, 6, 12, 15]\n    },\n    'DATA_ARROW': {\n      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',\n      height: 61,\n      width:  51,\n      heightElements: [],\n      widthElements: []\n    },\n    'DATA_STORE': {\n      d:'m  {mx},{my} ' +\n        'l  0,{e.y2} ' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\n        'l  0,-{e.y2} ' +\n        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\n        'm  -{e.x2},{e.y0}' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +\n        'm  -{e.x2},{e.y0}' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',\n      height: 61,\n      width:  61,\n      heightElements: [7, 10, 45],\n      widthElements:  [2, 58, 60]\n    },\n    'TEXT_ANNOTATION': {\n      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',\n      height: 30,\n      width: 10,\n      heightElements: [30],\n      widthElements: [10]\n    },\n    'MARKER_SUB_PROCESS': {\n      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_PARALLEL': {\n      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_SEQUENTIAL': {\n      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_COMPENSATION': {\n      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',\n      height: 10,\n      width: 21,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_LOOP': {\n      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +\n        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +\n        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +\n        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',\n      height: 13.9,\n      width: 13.7,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_ADHOC': {\n      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +\n        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +\n        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +\n        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +\n        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',\n      height: 4,\n      width: 15,\n      heightElements: [],\n      widthElements: []\n    },\n    'TASK_TYPE_SEND': {\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\n      height: 14,\n      width:  21,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'TASK_TYPE_SCRIPT': {\n      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +\n        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +\n        'm -7,-12 l 5,0 ' +\n        'm -4.5,3 l 4.5,0 ' +\n        'm -3,3 l 5,0' +\n        'm -4,3 l 5,0',\n      height: 15,\n      width:  12.6,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'TASK_TYPE_USER_1': {\n      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +\n        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +\n        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +\n        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +\n        'm -8,6 l 0,5.5 m 11,0 l 0,-5'\n    },\n    'TASK_TYPE_USER_2': {\n      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +\n        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '\n    },\n    'TASK_TYPE_USER_3': {\n      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +\n        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +\n        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'\n    },\n    'TASK_TYPE_MANUAL': {\n      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +\n        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +\n        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +\n        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +\n        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +\n        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +\n        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +\n        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +\n        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +\n        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +\n        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +\n        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'\n    },\n    'TASK_TYPE_INSTANTIATING_SEND': {\n      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'\n    },\n    'TASK_TYPE_SERVICE': {\n      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +\n        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +\n        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +\n        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +\n        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +\n        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +\n        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +\n        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +\n        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +\n        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +\n        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +\n        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +\n        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\n    },\n    'TASK_TYPE_SERVICE_FILL': {\n      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\n    },\n    'TASK_TYPE_BUSINESS_RULE_HEADER': {\n      d: 'm {mx},{my} 0,4 20,0 0,-4 z'\n    },\n    'TASK_TYPE_BUSINESS_RULE_MAIN': {\n      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +\n        'm 0,8 l 20,0 ' +\n        'm -13,-4 l 0,8'\n    },\n    'MESSAGE_FLOW_MARKER': {\n      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'\n    }\n  };\n\n  this.getRawPath = function getRawPath(pathId) {\n    return this.pathMap[pathId].d;\n  };\n\n  /**\n   * Scales the path to the given height and width.\n   * <h1>Use case</h1>\n   * <p>Use case is to scale the content of elements (event, gateways) based\n   * on the element bounding box's size.\n   * </p>\n   * <h1>Why not transform</h1>\n   * <p>Scaling a path with transform() will also scale the stroke and IE does not support\n   * the option 'non-scaling-stroke' to prevent this.\n   * Also there are use cases where only some parts of a path should be\n   * scaled.</p>\n   *\n   * @param {String} pathId The ID of the path.\n   * @param {Object} param <p>\n   *   Example param object scales the path to 60% size of the container (data.width, data.height).\n   *   <pre>\n   *   {\n   *     xScaleFactor: 0.6,\n   *     yScaleFactor:0.6,\n   *     containerWidth: data.width,\n   *     containerHeight: data.height,\n   *     position: {\n   *       mx: 0.46,\n   *       my: 0.2,\n   *     }\n   *   }\n   *   </pre>\n   *   <ul>\n   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>\n   *    <li>targetpathheight = yScaleFactor * containerHeight</li>\n   *    <li>Position is used to set the starting coordinate of the path. M is computed:\n    *    <ul>\n    *      <li>position.x * containerWidth</li>\n    *      <li>position.y * containerHeight</li>\n    *    </ul>\n    *    Center of the container <pre> position: {\n   *       mx: 0.5,\n   *       my: 0.5,\n   *     }</pre>\n   *     Upper left corner of the container\n   *     <pre> position: {\n   *       mx: 0.0,\n   *       my: 0.0,\n   *     }</pre>\n   *    </li>\n   *   </ul>\n   * </p>\n   *\n   */\n  this.getScaledPath = function getScaledPath(pathId, param) {\n    var rawPath = this.pathMap[pathId];\n\n    // positioning\n    // compute the start point of the path\n    var mx, my;\n\n    if (param.abspos) {\n      mx = param.abspos.x;\n      my = param.abspos.y;\n    } else {\n      mx = param.containerWidth * param.position.mx;\n      my = param.containerHeight * param.position.my;\n    }\n\n    var coordinates = {}; //map for the scaled coordinates\n    if (param.position) {\n\n      // path\n      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;\n      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;\n\n\n      //Apply height ratio\n      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {\n        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;\n      }\n\n      //Apply width ratio\n      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {\n        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;\n      }\n    }\n\n    //Apply value to raw path\n    var path = format(\n      rawPath.d, {\n        mx: mx,\n        my: my,\n        e: coordinates\n      }\n    );\n    return path;\n  };\n}\n\nmodule.exports = PathMap;\n\n////////// helpers //////////\n\n// copied from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js\nvar tokenRegex = /\\{([^\\}]+)\\}/g,\n    objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g; // matches .xxxxx or [\"xxxxx\"] to run over object properties\n\nfunction replacer(all, key, obj) {\n  var res = obj;\n  key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {\n    name = name || quotedName;\n    if (res) {\n      if (name in res) {\n        res = res[name];\n      }\n      typeof res == 'function' && isFunc && (res = res());\n    }\n  });\n  res = (res == null || res == obj ? all : res) + '';\n\n  return res;\n}\n\nfunction format(str, obj) {\n  return String(str).replace(tokenRegex, function(all, key) {\n    return replacer(all, key, obj);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/import/index.js":"module.exports = {\n  __depends__: [\n    require('diagram-js/lib/i18n/translate')\n  ],\n  bpmnImporter: [ 'type', require('./BpmnImporter') ]\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/import/BpmnImporter.js":"'use strict';\n\nvar assign = require('lodash/object/assign'),\n    map = require('lodash/collection/map');\n\nvar LabelUtil = require('../util/LabelUtil');\n\nvar TextUtil = require('diagram-js/lib/util/Text');\n\nvar is = require('../util/ModelUtil').is;\n\nvar hasExternalLabel = LabelUtil.hasExternalLabel,\n    getExternalLabelBounds = LabelUtil.getExternalLabelBounds,\n    isExpanded = require('../util/DiUtil').isExpanded,\n    elementToString = require('./Util').elementToString;\n\n\nfunction elementData(semantic, attrs) {\n  return assign({\n    id: semantic.id,\n    type: semantic.$type,\n    businessObject: semantic\n  }, attrs);\n}\n\nfunction collectWaypoints(waypoints) {\n  return map(waypoints, function(p) {\n    return { x: p.x, y: p.y };\n  });\n}\n\nfunction notYetDrawn(translate, semantic, refSemantic, property) {\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\n    element: elementToString(refSemantic),\n    referenced: elementToString(semantic),\n    property: property\n  }));\n}\n\n\n/**\n * An importer that adds bpmn elements to the canvas\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {ElementFactory} elementFactory\n * @param {ElementRegistry} elementRegistry\n */\nfunction BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate) {\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n\n  this._elementFactory = elementFactory;\n  this._elementRegistry = elementRegistry;\n  this._translate = translate;\n\n  this._textUtil = new TextUtil();\n}\n\nBpmnImporter.$inject = [ 'eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'translate' ];\n\nmodule.exports = BpmnImporter;\n\n\n/**\n * Add bpmn element (semantic) to the canvas onto the\n * specified parent shape.\n */\nBpmnImporter.prototype.add = function(semantic, parentElement) {\n\n  var di = semantic.di,\n      element,\n      translate = this._translate,\n      hidden;\n\n  // ROOT ELEMENT\n  // handle the special case that we deal with a\n  // invisible root element (process or collaboration)\n  if (is(di, 'bpmndi:BPMNPlane')) {\n\n    // add a virtual element (not being drawn)\n    element = this._elementFactory.createRoot(elementData(semantic));\n\n    this._canvas.setRootElement(element);\n  }\n\n  // SHAPE\n  else if (is(di, 'bpmndi:BPMNShape')) {\n\n    var collapsed = !isExpanded(semantic);\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    var bounds = semantic.di.bounds;\n\n    element = this._elementFactory.createShape(elementData(semantic, {\n      collapsed: collapsed,\n      hidden: hidden,\n      x: Math.round(bounds.x),\n      y: Math.round(bounds.y),\n      width: Math.round(bounds.width),\n      height: Math.round(bounds.height)\n    }));\n\n    if (is(semantic, 'bpmn:BoundaryEvent')) {\n      this._attachBoundary(semantic, element);\n    }\n\n    this._canvas.addShape(element, parentElement);\n  }\n\n  // CONNECTION\n  else if (is(di, 'bpmndi:BPMNEdge')) {\n\n    var source = this._getSource(semantic),\n        target = this._getTarget(semantic);\n\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    element = this._elementFactory.createConnection(elementData(semantic, {\n      hidden: hidden,\n      source: source,\n      target: target,\n      waypoints: collectWaypoints(semantic.di.waypoint)\n    }));\n\n    if (is(semantic, 'bpmn:DataAssociation')) {\n\n      // render always on top; this ensures DataAssociations\n      // are rendered correctly across different \"hacks\" people\n      // love to model such as cross participant / sub process\n      // associations\n      parentElement = null;\n    }\n\n    this._canvas.addConnection(element, parentElement);\n  } else {\n    throw new Error(translate('unknown di {di} for element {semantic}', {\n      di: elementToString(di),\n      semantic: elementToString(semantic)\n    }));\n  }\n  // (optional) LABEL\n  if (hasExternalLabel(semantic)) {\n    this.addLabel(semantic, element);\n  }\n\n\n  this._eventBus.fire('bpmnElement.added', { element: element });\n\n  return element;\n};\n\n\n/**\n * Attach the boundary element to the given host\n *\n * @param {ModdleElement} boundarySemantic\n * @param {djs.model.Base} boundaryElement\n */\nBpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {\n  var translate = this._translate;\n  var hostSemantic = boundarySemantic.attachedToRef;\n\n  if (!hostSemantic) {\n    throw new Error(translate('missing {semantic}#attachedToRef', {\n      semantic: elementToString(boundarySemantic)\n    }));\n  }\n\n  var host = this._elementRegistry.get(hostSemantic.id),\n      attachers = host && host.attachers;\n\n  if (!host) {\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\n  }\n\n  // wire element.host <> host.attachers\n  boundaryElement.host = host;\n\n  if (!attachers) {\n    host.attachers = attachers = [];\n  }\n\n  if (attachers.indexOf(boundaryElement) === -1) {\n    attachers.push(boundaryElement);\n  }\n};\n\n\n/**\n * add label for an element\n */\nBpmnImporter.prototype.addLabel = function(semantic, element) {\n  var bounds,\n      text,\n      label;\n\n  bounds = getExternalLabelBounds(semantic, element);\n\n  text = semantic.name;\n\n  if (text) {\n    // get corrected bounds from actual layouted text\n    bounds = getLayoutedBounds(bounds, text, this._textUtil);\n  }\n\n  label = this._elementFactory.createLabel(elementData(semantic, {\n    id: semantic.id + '_label',\n    labelTarget: element,\n    type: 'label',\n    hidden: element.hidden || !semantic.name,\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  }));\n\n  return this._canvas.addShape(label, element.parent);\n};\n\n/**\n * Return the drawn connection end based on the given side.\n *\n * @throws {Error} if the end is not yet drawn\n */\nBpmnImporter.prototype._getEnd = function(semantic, side) {\n\n  var element,\n      refSemantic,\n      type = semantic.$type,\n      translate = this._translate;\n\n  refSemantic = semantic[side + 'Ref'];\n\n  // handle mysterious isMany DataAssociation#sourceRef\n  if (side === 'source' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = refSemantic && refSemantic[0];\n  }\n\n  // fix source / target for DataInputAssociation / DataOutputAssociation\n  if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||\n      side === 'target' && type === 'bpmn:DataInputAssociation') {\n\n    refSemantic = semantic.$parent;\n  }\n\n  element = refSemantic && this._getElement(refSemantic);\n\n  if (element) {\n    return element;\n  }\n\n  if (refSemantic) {\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\n  } else {\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\n      semantic: elementToString(semantic),\n      side: side\n    }));\n  }\n};\n\nBpmnImporter.prototype._getSource = function(semantic) {\n  return this._getEnd(semantic, 'source');\n};\n\nBpmnImporter.prototype._getTarget = function(semantic) {\n  return this._getEnd(semantic, 'target');\n};\n\n\nBpmnImporter.prototype._getElement = function(semantic) {\n  return this._elementRegistry.get(semantic.id);\n};\n\n\n// TODO(nikku): repeating code (search for <getLayoutedBounds>)\n\nvar EXTERNAL_LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: '11px'\n};\n\nfunction getLayoutedBounds(bounds, text, textUtil) {\n\n  var layoutedLabelDimensions = textUtil.getDimensions(text, {\n    box: {\n      width: 90,\n      height: 30,\n      x: bounds.width / 2 + bounds.x,\n      y: bounds.height / 2 + bounds.y\n    },\n    style: EXTERNAL_LABEL_STYLE\n  });\n\n  // resize label shape to fit label text\n  return {\n    x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),\n    y: Math.round(bounds.y),\n    width: Math.ceil(layoutedLabelDimensions.width),\n    height: Math.ceil(layoutedLabelDimensions.height)\n  };\n}","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/util/LabelUtil.js":"'use strict';\n\nvar assign = require('lodash/object/assign');\n\nvar is = require('./ModelUtil').is;\n\nvar DEFAULT_LABEL_SIZE = module.exports.DEFAULT_LABEL_SIZE = {\n  width: 90,\n  height: 20\n};\n\nvar FLOW_LABEL_INDENT = module.exports.FLOW_LABEL_INDENT = 15;\n\n\n/**\n * Returns true if the given semantic has an external label\n *\n * @param {BpmnElement} semantic\n * @return {Boolean} true if has label\n */\nmodule.exports.hasExternalLabel = function(semantic) {\n  return is(semantic, 'bpmn:Event') ||\n         is(semantic, 'bpmn:Gateway') ||\n         is(semantic, 'bpmn:DataStoreReference') ||\n         is(semantic, 'bpmn:DataObjectReference') ||\n         is(semantic, 'bpmn:SequenceFlow') ||\n         is(semantic, 'bpmn:MessageFlow');\n};\n\n/**\n * Get the position for sequence flow labels\n *\n * @param  {Array<Point>} waypoints\n * @return {Point} the label position\n */\nfunction getFlowLabelPosition(waypoints) {\n\n  // get the waypoints mid\n  var mid = waypoints.length / 2 - 1;\n\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n\n  // get position\n  var position = getWaypointsMid(waypoints);\n\n  // calculate angle\n  var angle = Math.atan( (second.y - first.y) / (second.x - first.x) );\n\n  var x = position.x,\n      y = position.y;\n\n  if ( Math.abs(angle) < Math.PI / 2 ) {\n    y -= FLOW_LABEL_INDENT;\n  } else {\n    x += FLOW_LABEL_INDENT;\n  }\n\n  return { x: x, y: y };\n}\n\nmodule.exports.getFlowLabelPosition = getFlowLabelPosition;\n\n/**\n * Get the middle of a number of waypoints\n *\n * @param  {Array<Point>} waypoints\n * @return {Point} the mid point\n */\nfunction getWaypointsMid(waypoints) {\n\n  var mid = waypoints.length / 2 - 1;\n\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n\n  return {\n    x: first.x + (second.x - first.x) / 2,\n    y: first.y + (second.y - first.y) / 2\n  };\n}\n\nmodule.exports.getWaypointsMid = getWaypointsMid;\n\n\nfunction getExternalLabelMid(element) {\n\n  if (element.waypoints) {\n    return getFlowLabelPosition(element.waypoints);\n  } else {\n    return {\n      x: element.x + element.width / 2,\n      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2\n    };\n  }\n}\n\nmodule.exports.getExternalLabelMid = getExternalLabelMid;\n\n\n/**\n * Returns the bounds of an elements label, parsed from the elements DI or\n * generated from its bounds.\n *\n * @param {BpmnElement} semantic\n * @param {djs.model.Base} element\n */\nmodule.exports.getExternalLabelBounds = function(semantic, element) {\n\n  var mid,\n      size,\n      bounds,\n      di = semantic.di,\n      label = di.label;\n\n  if (label && label.bounds) {\n    bounds = label.bounds;\n\n    size = {\n      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),\n      height: bounds.height\n    };\n\n    mid = {\n      x: bounds.x + bounds.width / 2,\n      y: bounds.y + bounds.height / 2\n    };\n  } else {\n\n    mid = getExternalLabelMid(element);\n\n    size = DEFAULT_LABEL_SIZE;\n  }\n\n  return assign({\n    x: mid.x - size.width / 2,\n    y: mid.y - size.height / 2\n  }, size);\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/Gruntfile.js":"'use strict';\n\nmodule.exports = function(grunt) {\n\n  require('load-grunt-tasks')(grunt);\n  require('time-grunt')(grunt);\n\n  /* global process */\n\n  // configures browsers to run test against\n  // any of [ 'PhantomJS', 'Chrome', 'Firefox', 'IE']\n  var TEST_BROWSERS = ((process.env.TEST_BROWSERS || '').replace(/^\\s+|\\s+$/, '') || 'PhantomJS').split(/\\s*,\\s*/g);\n\n  // project configuration\n  grunt.initConfig({\n\n    pkg: grunt.file.readJSON('package.json'),\n\n    config: {\n      sources: 'lib',\n      tests: 'test',\n      dist: '../bower-bpmn-js/dist'\n    },\n\n    eslint: {\n      check: {\n        src: [\n          '{lib,test}/**/*.js'\n        ]\n      },\n      fix: {\n        src: [\n          '{lib,test}/**/*.js'\n        ],\n        options: {\n          fix: true\n        }\n      }\n    },\n\n    release: {\n      options: {\n        tagName: 'v<%= version %>',\n        commitMessage: 'chore(project): release v<%= version %>',\n        tagMessage: 'chore(project): tag v<%= version %>'\n      }\n    },\n\n    karma: {\n      options: {\n        configFile: '<%= config.tests %>/config/karma.unit.js'\n      },\n      single: {\n        singleRun: true,\n        autoWatch: false,\n\n        browsers: TEST_BROWSERS\n      },\n      unit: {\n        browsers: TEST_BROWSERS\n      },\n      translations: {\n        singleRun: true,\n        autoWatch: false,\n\n        reporters: [ 'dots', 'translation-reporter' ],\n\n        plugins: [\n          'karma-*',\n          require('./test/config/translation-reporter')\n        ],\n\n        envPreprocessor: [\n          'TRANSLATIONS'\n        ],\n\n        browsers: TEST_BROWSERS\n      }\n    },\n\n    bundle: {\n      viewer: {\n        name: 'bpmn-viewer',\n        src: '<%= config.sources %>/Viewer.js',\n        dest: '<%= config.dist %>'\n      },\n      navigated_viewer: {\n        name: 'bpmn-navigated-viewer',\n        src: '<%= config.sources %>/NavigatedViewer.js',\n        dest: '<%= config.dist %>'\n      },\n      modeler: {\n        name: 'bpmn-modeler',\n        src: '<%= config.sources %>/Modeler.js',\n        dest: '<%= config.dist %>'\n      }\n    },\n\n    copy: {\n      bpmn_js: {\n        files: [\n          { expand: true, cwd: 'assets', src: [ '**' ], dest: '<%= config.dist %>/assets' }\n        ]\n      },\n\n      diagram_js: {\n        files: [\n          { expand: true, cwd: 'node_modules/diagram-js/assets', src: [ '**' ], dest: '<%= config.dist %>/assets' }\n        ]\n      }\n    }\n  });\n\n  grunt.loadTasks('tasks');\n\n\n  // tasks\n  grunt.registerTask('extract-translations', [ 'karma:translations' ]);\n\n  grunt.registerTask('test', [ 'karma:single' ]);\n\n  grunt.registerTask('lint', [ 'eslint:check' ]);\n\n  grunt.registerTask('auto-test', [ 'karma:unit' ]);\n\n  grunt.registerTask('build', [ 'bundle', 'copy' ]);\n\n  grunt.registerTask('default', [ 'lint', 'test', 'build' ]);\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/Modeler.js":"'use strict';\n\nvar inherits = require('inherits');\n\nvar Ids = require('ids');\n\nvar Viewer = require('./Viewer');\n\nvar NavigatedViewer = require('./NavigatedViewer');\n\nvar initialDiagram =\n  '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n  '<bpmn:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ' +\n                    'xmlns:bpmn=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" ' +\n                    'xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" ' +\n                    'xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" ' +\n                    'targetNamespace=\"http://bpmn.io/schema/bpmn\" ' +\n                    'id=\"Definitions_1\">' +\n    '<bpmn:process id=\"Process_1\" isExecutable=\"false\">' +\n      '<bpmn:startEvent id=\"StartEvent_1\"/>' +\n    '</bpmn:process>' +\n    '<bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">' +\n      '<bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Process_1\">' +\n        '<bpmndi:BPMNShape id=\"_BPMNShape_StartEvent_2\" bpmnElement=\"StartEvent_1\">' +\n          '<dc:Bounds height=\"36.0\" width=\"36.0\" x=\"173.0\" y=\"102.0\"/>' +\n        '</bpmndi:BPMNShape>' +\n      '</bpmndi:BPMNPlane>' +\n    '</bpmndi:BPMNDiagram>' +\n  '</bpmn:definitions>';\n\n\n/**\n * A modeler for BPMN 2.0 diagrams.\n *\n *\n * ## Extending the Modeler\n *\n * In order to extend the viewer pass extension modules to bootstrap via the\n * `additionalModules` option. An extension module is an object that exposes\n * named services.\n *\n * The following example depicts the integration of a simple\n * logging component that integrates with interaction events:\n *\n *\n * ```javascript\n *\n * // logging component\n * function InteractionLogger(eventBus) {\n *   eventBus.on('element.hover', function(event) {\n *     console.log()\n *   })\n * }\n *\n * InteractionLogger.$inject = [ 'eventBus' ]; // minification save\n *\n * // extension module\n * var extensionModule = {\n *   __init__: [ 'interactionLogger' ],\n *   interactionLogger: [ 'type', InteractionLogger ]\n * };\n *\n * // extend the viewer\n * var bpmnModeler = new Modeler({ additionalModules: [ extensionModule ] });\n * bpmnModeler.importXML(...);\n * ```\n *\n *\n * ## Customizing / Replacing Components\n *\n * You can replace individual diagram components by redefining them in override modules.\n * This works for all components, including those defined in the core.\n *\n * Pass in override modules via the `options.additionalModules` flag like this:\n *\n * ```javascript\n * function CustomContextPadProvider(contextPad) {\n *\n *   contextPad.registerProvider(this);\n *\n *   this.getContextPadEntries = function(element) {\n *     // no entries, effectively disable the context pad\n *     return {};\n *   };\n * }\n *\n * CustomContextPadProvider.$inject = [ 'contextPad' ];\n *\n * var overrideModule = {\n *   contextPadProvider: [ 'type', CustomContextPadProvider ]\n * };\n *\n * var bpmnModeler = new Modeler({ additionalModules: [ overrideModule ]});\n * ```\n *\n * @param {Object} [options] configuration options to pass to the viewer\n * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\n * @param {String|Number} [options.width] the width of the viewer\n * @param {String|Number} [options.height] the height of the viewer\n * @param {Object} [options.moddleExtensions] extension packages to provide\n * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\n * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\n */\nfunction Modeler(options) {\n  Viewer.call(this, options);\n\n  // hook ID collection into the modeler\n  this.on('import.parse.complete', function(event) {\n    if (!event.error) {\n      this._collectIds(event.definitions, event.context);\n    }\n  }, this);\n\n  this.on('diagram.destroy', function() {\n    this.moddle.ids.clear();\n  }, this);\n}\n\ninherits(Modeler, Viewer);\n\nmodule.exports = Modeler;\n\nmodule.exports.Viewer = Viewer;\n\nmodule.exports.NavigatedViewer = NavigatedViewer;\n\n/**\n * Create a new diagram to start modeling.\n *\n * @param {Function} [done]\n */\nModeler.prototype.createDiagram = function(done) {\n  return this.importXML(initialDiagram, done);\n};\n\n/**\n * Create a moddle instance, attaching ids to it.\n *\n * @param {Object} options\n */\nModeler.prototype._createModdle = function(options) {\n  var moddle = Viewer.prototype._createModdle.call(this, options);\n\n  // attach ids to moddle to be able to track\n  // and validated ids in the BPMN 2.0 XML document\n  // tree\n  moddle.ids = new Ids([ 32, 36, 1 ]);\n\n  return moddle;\n};\n\n/**\n * Collect ids processed during parsing of the\n * definitions object.\n *\n * @param {ModdleElement} definitions\n * @param {Context} context\n */\nModeler.prototype._collectIds = function(definitions, context) {\n\n  var moddle = definitions.$model,\n      ids = moddle.ids,\n      id;\n\n  // remove references from previous import\n  ids.clear();\n\n  for (id in context.elementsById) {\n    ids.claim(id, context.elementsById[id]);\n  }\n};\n\n\nModeler.prototype._interactionModules = [\n  // non-modeling components\n  require('diagram-js/lib/navigation/movecanvas'),\n  require('diagram-js/lib/navigation/touch'),\n  require('diagram-js/lib/navigation/zoomscroll')\n];\n\nModeler.prototype._modelingModules = [\n  // modeling components\n  require('diagram-js/lib/features/auto-scroll'),\n  require('diagram-js/lib/features/bendpoints'),\n  require('diagram-js/lib/features/move'),\n  require('diagram-js/lib/features/resize'),\n  require('./features/auto-resize'),\n  require('./features/editor-actions'),\n  require('./features/context-pad'),\n  require('./features/keyboard'),\n  require('./features/label-editing'),\n  require('./features/modeling'),\n  require('./features/palette'),\n  require('./features/replace-preview'),\n  require('./features/snapping')\n];\n\n\n// modules the modeler is composed of\n//\n// - viewer modules\n// - interaction modules\n// - modeling modules\n\nModeler.prototype._modules = [].concat(\n  Modeler.prototype._modules,\n  Modeler.prototype._interactionModules,\n  Modeler.prototype._modelingModules);\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/NavigatedViewer.js":"'use strict';\n\nvar inherits = require('inherits');\n\nvar Viewer = require('./Viewer');\n\n\n/**\n * A viewer that includes mouse navigation facilities\n *\n * @param {Object} options\n */\nfunction NavigatedViewer(options) {\n  Viewer.call(this, options);\n}\n\ninherits(NavigatedViewer, Viewer);\n\nmodule.exports = NavigatedViewer;\n\nNavigatedViewer.prototype._navigationModules = [\n  require('diagram-js/lib/navigation/zoomscroll'),\n  require('diagram-js/lib/navigation/movecanvas')\n];\n\nNavigatedViewer.prototype._modules = [].concat(\n  NavigatedViewer.prototype._modules,\n  NavigatedViewer.prototype._navigationModules);","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/tasks/bundle.js":"'use strict';\n\nvar browserify = require('browserify'),\n    derequire = require('browserify-derequire'),\n    UglifyJS = require('uglify-js'),\n    collapse = require('bundle-collapser/plugin'),\n    concat = require('source-map-concat'),\n    fs = require('fs'),\n    path = require('path');\n\n\nvar BANNER = fs.readFileSync(__dirname + '/banner.txt', 'utf8'),\n    BANNER_MIN = fs.readFileSync(__dirname + '/banner-min.txt', 'utf8');\n\nvar SOURCE_MAP_HEADER = '//# sourceMappingURL=data:application/json;charset=utf-8;base64,';\n\n\nfunction extractSourceMap(content) {\n\n  var idx = content.indexOf(SOURCE_MAP_HEADER),\n      map, code;\n\n  if (idx !== -1) {\n    code = content.substring(0, idx);\n    map = content.substring(idx + SOURCE_MAP_HEADER.length);\n\n    map = new Buffer(map, 'base64').toString();\n\n    map = map.replace(/\\\\\\\\/g, '/'); // convert \\\\ -> /\n\n    var dir = __dirname;\n\n    var dirPattern = dir.replace(/\\\\/g, '/').replace(/\\./g, '\\\\.') + '/';\n\n    var pattern = new RegExp(dirPattern, 'g');\n\n    map = map.replace(pattern, '');\n\n    return {\n      code: code,\n      map: JSON.parse(map)\n    };\n  } else {\n    throw new Error('no attached source map');\n  }\n}\n\n\nfunction uglify(bundle, preamble) {\n  return UglifyJS.minify(bundle.code, {\n    fromString: true,\n    output: {\n      preamble: preamble\n    }\n  });\n}\n\n\nfunction Timer() {\n  this.reset();\n}\n\nTimer.prototype.done = function(message) {\n  console.log(message, '[' + (this.now() - this.start) + 'ms]');\n  this.reset();\n};\n\nTimer.prototype.reset = function() {\n  this.start = this.now();\n};\n\nTimer.prototype.now = function() {\n  return new Date().getTime();\n};\n\n\nmodule.exports = function(grunt) {\n\n  grunt.registerMultiTask('bundle', function(target) {\n\n    var data = this.data,\n        variant = data.name,\n        dest = data.dest,\n        src = path.resolve(data.src);\n\n    grunt.config.set('config.variant', variant);\n\n    var done = this.async();\n\n    var browserifyOptions = {\n      standalone: 'BpmnJS',\n      debug: true,\n      builtins: false,\n      insertGlobalVars: {\n        process: function () {\n            return 'undefined';\n        },\n        Buffer: function () {\n            return 'undefined';\n        }\n      }\n    };\n\n    var timer = new Timer();\n\n    var targetFileBase = path.join(dest, variant);\n\n    var banner = grunt.template.process(BANNER, grunt.config.get()),\n        bannerMin = grunt.template.process(BANNER_MIN, grunt.config.get());\n\n    browserify(browserifyOptions)\n      .plugin(derequire)\n      .plugin(collapse)\n      .add(src)\n      .bundle(function(err, result) {\n\n        timer.done('bundled');\n\n        if (err) {\n          return done(err);\n        }\n\n        var bundled, minified;\n\n        bundled = extractSourceMap(result.toString('utf8'));\n\n        timer.done('extracted source map');\n\n        try {\n          minified = uglify(bundled, bannerMin);\n        } catch (e) {\n          return done(e);\n        }\n\n        timer.done('minified');\n\n        var bannerBundled;\n\n        try {\n          bannerBundled = concat([ bundled ])\n                            .prepend(banner + '\\n')\n                            .add('//# sourceMappingURL=' + variant + '.js.map')\n                            .toStringWithSourceMap();\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n\n        timer.done('added banner');\n\n        grunt.file.write(targetFileBase + '.js', bannerBundled.code, 'utf8');\n        grunt.file.write(targetFileBase + '.js.map', bannerBundled.map, 'utf8');\n\n        grunt.file.write(targetFileBase + '.min.js', minified.code, 'utf8');\n\n        timer.done('all saved');\n\n        done();\n      });\n\n  });\n\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/util/PoweredByUtil.js":"/**\n * This file must not be changed or exchanged.\n *\n * @see http://bpmn.io/license for more information.\n */\n\n'use strict';\n\nvar domify = require('min-dom/lib/domify');\n\nvar domDelegate = require('min-dom/lib/delegate');\n\n/* jshint -W101 */\n\n// inlined ../resources/bpmnjs.png\nvar logoData = module.exports.BPMNIO_LOGO = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';\n\n/* jshint +W101 */\n\n\nfunction css(attrs) {\n  return attrs.join(';');\n}\n\nvar LIGHTBOX_STYLES = css([\n  'z-index: 1001',\n  'position: fixed',\n  'top: 0',\n  'left: 0',\n  'right: 0',\n  'bottom: 0'\n]);\n\nvar BACKDROP_STYLES = css([\n  'width: 100%',\n  'height: 100%',\n  'background: rgba(0,0,0,0.2)'\n]);\n\nvar NOTICE_STYLES = css([\n  'position: absolute',\n  'left: 50%',\n  'top: 40%',\n  'margin: 0 -130px',\n  'width: 260px',\n  'padding: 10px',\n  'background: white',\n  'border: solid 1px #AAA',\n  'border-radius: 3px',\n  'font-family: Helvetica, Arial, sans-serif',\n  'font-size: 14px',\n  'line-height: 1.2em'\n]);\n\nvar LIGHTBOX_MARKUP =\n  '<div class=\"bjs-powered-by-lightbox\" style=\"' + LIGHTBOX_STYLES + '\">' +\n    '<div class=\"backdrop\" style=\"' + BACKDROP_STYLES + '\"></div>' +\n    '<div class=\"notice\" style=\"' + NOTICE_STYLES + '\">' +\n      '<a href=\"http://bpmn.io\" target=\"_blank\" style=\"float: left; margin-right: 10px\">' +\n        '<img src=\"data:image/png;base64,'+ logoData +'\">' +\n      '</a>' +\n      'Web-based tooling for BPMN, DMN and CMMN diagrams ' +\n      'powered by <a href=\"http://bpmn.io\" target=\"_blank\">bpmn.io</a>.' +\n    '</div>' +\n  '</div>';\n\n\nvar lightbox;\n\nfunction open() {\n\n  if (!lightbox) {\n    lightbox = domify(LIGHTBOX_MARKUP);\n\n    domDelegate.bind(lightbox, '.backdrop', 'click', function(event) {\n      document.body.removeChild(lightbox);\n    });\n  }\n\n  document.body.appendChild(lightbox);\n}\n\nmodule.exports.open = open;","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResize.js":"var AutoResize = require('diagram-js/lib/features/auto-resize/AutoResize');\n\nvar inherits = require('inherits');\n\nvar is = require('../../util/ModelUtil').is;\n\n/**\n * Sub class of the AutoResize module which implements a BPMN\n * specific resize function.\n */\nfunction BpmnAutoResize(eventBus, elementRegistry, modeling, rules) {\n  AutoResize.call(this, eventBus, elementRegistry, modeling, rules);\n}\n\nBpmnAutoResize.$inject = [ 'eventBus', 'elementRegistry', 'modeling', 'rules' ];\n\ninherits(BpmnAutoResize, AutoResize);\n\nmodule.exports = BpmnAutoResize;\n\n\n/**\n * Resize shapes and lanes\n *\n * @param  {djs.model.Shape} target\n * @param  {Object} newBounds\n */\nBpmnAutoResize.prototype.resize = function(target, newBounds) {\n\n  if (is(target, 'bpmn:Participant')) {\n    this._modeling.resizeLane(target, newBounds);\n  } else {\n    this._modeling.resizeShape(target, newBounds);\n  }\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResizeProvider.js":"'use strict';\n\nvar is = require('../../util/ModelUtil').is;\n\nvar inherits = require('inherits');\n\nvar forEach = require('lodash/collection/forEach');\n\nvar AutoResizeProvider = require('diagram-js/lib/features/auto-resize/AutoResizeProvider');\n\n/**\n * This module is a provider for automatically resizing parent BPMN elements\n */\nfunction BpmnAutoResizeProvider(eventBus, modeling) {\n  AutoResizeProvider.call(this, eventBus);\n\n  this._modeling = modeling;\n}\n\ninherits(BpmnAutoResizeProvider, AutoResizeProvider);\n\nBpmnAutoResizeProvider.$inject = [ 'eventBus', 'modeling' ];\n\nmodule.exports = BpmnAutoResizeProvider;\n\n\n/**\n * Check if the given target can be expanded\n *\n * @param  {djs.model.Shape} target\n *\n * @return {boolean}\n */\nBpmnAutoResizeProvider.prototype.canResize = function(elements, target) {\n\n  if (!is(target, 'bpmn:Participant') && !is(target, 'bpmn:Lane') && !(is(target, 'bpmn:SubProcess'))) {\n    return false;\n  }\n\n  var canResize = true;\n\n  forEach(elements, function(element) {\n\n    if (is(element, 'bpmn:Lane') || element.labelTarget) {\n      canResize = false;\n      return;\n    }\n  });\n\n  return canResize;\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js":"'use strict';\n\n\nvar assign = require('lodash/object/assign'),\n    forEach = require('lodash/collection/forEach'),\n    isArray = require('lodash/lang/isArray'),\n    is = require('../../util/ModelUtil').is,\n    isExpanded = require('../../util/DiUtil').isExpanded,\n    isAny = require('../modeling/util/ModelingUtil').isAny,\n    getChildLanes = require('../modeling/util/LaneUtil').getChildLanes,\n    isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,\n    hasPrimaryModifier = require('diagram-js/lib/util/Mouse').hasPrimaryModifier;\n\n/**\n * A provider for BPMN 2.0 elements context pad\n */\nfunction ContextPadProvider(eventBus, contextPad, modeling, elementFactory,\n                            connect, create, popupMenu,\n                            canvas, rules, translate) {\n\n  contextPad.registerProvider(this);\n\n  this._contextPad = contextPad;\n\n  this._modeling = modeling;\n\n  this._elementFactory = elementFactory;\n  this._connect = connect;\n  this._create = create;\n  this._popupMenu = popupMenu;\n  this._canvas  = canvas;\n  this._rules = rules;\n  this._translate = translate;\n\n\n  eventBus.on('create.end', 250, function(event) {\n    var shape = event.context.shape;\n\n    if (!hasPrimaryModifier(event)) {\n      return;\n    }\n\n    var entries = contextPad.getEntries(shape);\n\n    if (entries.replace) {\n      entries.replace.action.click(event, shape);\n    }\n  });\n}\n\nContextPadProvider.$inject = [\n  'eventBus',\n  'contextPad',\n  'modeling',\n  'elementFactory',\n  'connect',\n  'create',\n  'popupMenu',\n  'canvas',\n  'rules',\n  'translate'\n];\n\nmodule.exports = ContextPadProvider;\n\n\nContextPadProvider.prototype.getContextPadEntries = function(element) {\n\n  var contextPad = this._contextPad,\n      modeling = this._modeling,\n\n      elementFactory = this._elementFactory,\n      connect = this._connect,\n      create = this._create,\n      popupMenu = this._popupMenu,\n      canvas = this._canvas,\n      rules = this._rules,\n\n      translate = this._translate;\n\n  var actions = {};\n\n  if (element.type === 'label') {\n    return actions;\n  }\n\n  var businessObject = element.businessObject;\n\n  function startConnect(event, element, autoActivate) {\n    connect.start(event, element, autoActivate);\n  }\n\n  function removeElement(e) {\n    modeling.removeElements([ element ]);\n  }\n\n  function getReplaceMenuPosition(element) {\n\n    var Y_OFFSET = 5;\n\n    var diagramContainer = canvas.getContainer(),\n        pad = contextPad.getPad(element).html;\n\n    var diagramRect = diagramContainer.getBoundingClientRect(),\n        padRect = pad.getBoundingClientRect();\n\n    var top = padRect.top - diagramRect.top;\n    var left = padRect.left - diagramRect.left;\n\n    var pos = {\n      x: left,\n      y: top + padRect.height + Y_OFFSET\n    };\n\n    return pos;\n  }\n\n\n  /**\n   * Create an append action\n   *\n   * @param {String} type\n   * @param {String} className\n   * @param {String} [title]\n   * @param {Object} [options]\n   *\n   * @return {Object} descriptor\n   */\n  function appendAction(type, className, title, options) {\n\n    if (typeof title !== 'string') {\n      options = title;\n      title = translate('Append {type}', { type: type.replace(/^bpmn\\:/, '') });\n    }\n\n    function appendListener(event, element) {\n\n      var shape = elementFactory.createShape(assign({ type: type }, options));\n      create.start(event, shape, element);\n    }\n\n    return {\n      group: 'model',\n      className: className,\n      title: title,\n      action: {\n        dragstart: appendListener,\n        click: appendListener\n      }\n    };\n  }\n\n  function splitLaneHandler(count) {\n\n    return function(event, element) {\n      // actual split\n      modeling.splitLane(element, count);\n\n      // refresh context pad after split to\n      // get rid of split icons\n      contextPad.open(element, true);\n    };\n  }\n\n\n  if (isAny(businessObject, [ 'bpmn:Lane', 'bpmn:Participant' ]) && isExpanded(businessObject)) {\n\n    var childLanes = getChildLanes(element);\n\n    assign(actions, {\n      'lane-insert-above': {\n        group: 'lane-insert-above',\n        className: 'bpmn-icon-lane-insert-above',\n        title: translate('Add Lane above'),\n        action: {\n          click: function(event, element) {\n            modeling.addLane(element, 'top');\n          }\n        }\n      }\n    });\n\n    if (childLanes.length < 2) {\n\n      if (element.height >= 120) {\n        assign(actions, {\n          'lane-divide-two': {\n            group: 'lane-divide',\n            className: 'bpmn-icon-lane-divide-two',\n            title: translate('Divide into two Lanes'),\n            action: {\n              click: splitLaneHandler(2)\n            }\n          }\n        });\n      }\n\n      if (element.height >= 180) {\n        assign(actions, {\n          'lane-divide-three': {\n            group: 'lane-divide',\n            className: 'bpmn-icon-lane-divide-three',\n            title: translate('Divide into three Lanes'),\n            action: {\n              click: splitLaneHandler(3)\n            }\n          }\n        });\n      }\n    }\n\n    assign(actions, {\n      'lane-insert-below': {\n        group: 'lane-insert-below',\n        className: 'bpmn-icon-lane-insert-below',\n        title: translate('Add Lane below'),\n        action: {\n          click: function(event, element) {\n            modeling.addLane(element, 'bottom');\n          }\n        }\n      }\n    });\n\n  }\n\n  if (is(businessObject, 'bpmn:FlowNode')) {\n\n    if (is(businessObject, 'bpmn:EventBasedGateway')) {\n\n      assign(actions, {\n        'append.receive-task': appendAction('bpmn:ReceiveTask', 'bpmn-icon-receive-task'),\n        'append.message-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-message',\n                                                  { eventDefinitionType: 'bpmn:MessageEventDefinition' }),\n        'append.timer-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-timer',\n                                                  { eventDefinitionType: 'bpmn:TimerEventDefinition' }),\n        'append.condtion-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-condition',\n                                                  { eventDefinitionType: 'bpmn:ConditionalEventDefinition' }),\n        'append.signal-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-signal',\n                                                  { eventDefinitionType: 'bpmn:SignalEventDefinition' })\n      });\n    } else\n\n    if (isEventType(businessObject, 'bpmn:BoundaryEvent', 'bpmn:CompensateEventDefinition')) {\n\n      assign(actions, {\n        'append.compensation-activity':\n            appendAction('bpmn:Task', 'bpmn-icon-task', translate('Append compensation activity'), {\n              isForCompensation: true\n            })\n      });\n    } else\n\n    if (!is(businessObject, 'bpmn:EndEvent') &&\n        !businessObject.isForCompensation &&\n        !isEventType(businessObject, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition') &&\n        !isEventSubProcess(businessObject)) {\n\n      assign(actions, {\n        'append.end-event': appendAction('bpmn:EndEvent', 'bpmn-icon-end-event-none'),\n        'append.gateway': appendAction('bpmn:ExclusiveGateway', 'bpmn-icon-gateway-xor'),\n        'append.append-task': appendAction('bpmn:Task', 'bpmn-icon-task'),\n        'append.intermediate-event': appendAction('bpmn:IntermediateThrowEvent',\n                                                  'bpmn-icon-intermediate-event-none')\n      });\n    }\n  }\n\n  var replaceMenu;\n\n  if (popupMenu._providers['bpmn-replace']) {\n    replaceMenu = popupMenu.create('bpmn-replace', element);\n  }\n\n  if (replaceMenu && !replaceMenu.isEmpty()) {\n\n    // Replace menu entry\n    assign(actions, {\n      'replace': {\n        group: 'edit',\n        className: 'bpmn-icon-screw-wrench',\n        title: translate('Change type'),\n        action: {\n          click: function(event, element) {\n            replaceMenu.open(assign(getReplaceMenuPosition(element), {\n              cursor: { x: event.x, y: event.y }\n            }), element);\n          }\n        }\n      }\n    });\n  }\n\n  if (isAny(businessObject, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ]) ) {\n\n    assign(actions, {\n      'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation'),\n\n      'connect': {\n        group: 'connect',\n        className: 'bpmn-icon-connection-multi',\n        title: translate('Connect using ' +\n                  (businessObject.isForCompensation ? '' : 'Sequence/MessageFlow or ') +\n                  'Association'),\n        action: {\n          click: startConnect,\n          dragstart: startConnect\n        }\n      }\n    });\n  }\n\n  if (isAny(businessObject, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {\n    assign(actions, {\n      'connect': {\n        group: 'connect',\n        className: 'bpmn-icon-connection-multi',\n        title: translate('Connect using DataInputAssociation'),\n        action: {\n          click: startConnect,\n          dragstart: startConnect\n        }\n      }\n    });\n  }\n\n  // delete element entry, only show if allowed by rules\n  var deleteAllowed = rules.allowed('elements.delete', { elements: [ element ] });\n\n  if (isArray(deleteAllowed)) {\n    // was the element returned as a deletion candidate?\n    deleteAllowed = deleteAllowed[0] === element;\n  }\n\n  if (deleteAllowed) {\n    assign(actions, {\n      'delete': {\n        group: 'edit',\n        className: 'bpmn-icon-trash',\n        title: translate('Remove'),\n        action: {\n          click: removeElement,\n          dragstart: removeElement\n        }\n      }\n    });\n  }\n\n  return actions;\n};\n\nfunction isEventType(eventBo, type, definition) {\n\n  var isType = eventBo.$instanceOf(type);\n  var isDefinition = false;\n\n  var definitions = eventBo.eventDefinitions || [];\n  forEach(definitions, function(def) {\n    if (def.$type === definition) {\n      isDefinition = true;\n    }\n  });\n\n  return isType && isDefinition;\n}\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/util/ModelingUtil.js":"'use strict';\n\nvar any = require('lodash/collection/any');\n\nvar is = require('../../../util/ModelUtil').is;\n\n\n/**\n * Return true if element has any of the given types.\n *\n * @param {djs.model.Base} element\n * @param {Array<String>} types\n *\n * @return {Boolean}\n */\nfunction isAny(element, types) {\n  return any(types, function(t) {\n    return is(element, t);\n  });\n}\n\nmodule.exports.isAny = isAny;\n\n\n/**\n * Return the parent of the element with any of the given types.\n *\n * @param {djs.model.Base} element\n * @param {String|Array<String>} anyType\n *\n * @return {djs.model.Base}\n */\nfunction getParent(element, anyType) {\n\n  if (typeof anyType === 'string') {\n    anyType = [ anyType ];\n  }\n\n  while ((element = element.parent)) {\n    if (isAny(element, anyType)) {\n      return element;\n    }\n  }\n\n  return null;\n}\n\nmodule.exports.getParent = getParent;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/util/LaneUtil.js":"'use strict';\n\nvar is = require('../../../util/ModelUtil').is;\n\nvar getParent = require('./ModelingUtil').getParent;\n\nvar asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL,\n    substractTRBL = require('diagram-js/lib/features/resize/ResizeUtil').substractTRBL,\n    resizeTRBL = require('diagram-js/lib/features/resize/ResizeUtil').resizeTRBL;\n\nvar abs = Math.abs;\n\n\nfunction getTRBLResize(oldBounds, newBounds) {\n  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));\n}\n\n\nvar LANE_PARENTS = [\n  'bpmn:Participant',\n  'bpmn:Process',\n  'bpmn:SubProcess'\n];\n\nvar LANE_INDENTATION = 30;\n\nmodule.exports.LANE_INDENTATION = LANE_INDENTATION;\n\n\n/**\n * Collect all lane shapes in the given paren\n *\n * @param  {djs.model.Shape} shape\n * @param  {Array<djs.model.Base>} [collectedShapes]\n *\n * @return {Array<djs.model.Base>}\n */\nfunction collectLanes(shape, collectedShapes) {\n\n  collectedShapes = collectedShapes || [];\n\n  shape.children.filter(function(s) {\n    if (is(s, 'bpmn:Lane')) {\n      collectLanes(s, collectedShapes);\n\n      collectedShapes.push(s);\n    }\n  });\n\n  return collectedShapes;\n}\n\nmodule.exports.collectLanes = collectLanes;\n\n/**\n * Return the lane children of the given element.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Array<djs.model.Shape>}\n */\nfunction getChildLanes(shape) {\n  return shape.children.filter(function(c) {\n    return is(c, 'bpmn:Lane');\n  });\n}\n\nmodule.exports.getChildLanes = getChildLanes;\n\n/**\n * Return the root element containing the given lane shape\n *\n * @param {djs.model.Shape} shape\n *\n * @return {djs.model.Shape}\n */\nfunction getLanesRoot(shape) {\n  return getParent(shape, LANE_PARENTS) || shape;\n}\n\nmodule.exports.getLanesRoot = getLanesRoot;\n\n\n/**\n * Compute the required resize operations for lanes\n * adjacent to the given shape, assuming it will be\n * resized to the given new bounds.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n *\n * @return {Array<Object>}\n */\nfunction computeLanesResize(shape, newBounds) {\n\n  var rootElement = getLanesRoot(shape);\n\n  var initialShapes = is(rootElement, 'bpmn:Process') ? [] : [ rootElement ];\n\n  var allLanes = collectLanes(rootElement, initialShapes),\n      shapeTrbl = asTRBL(shape),\n      shapeNewTrbl = asTRBL(newBounds),\n      trblResize = getTRBLResize(shape, newBounds),\n      resizeNeeded = [];\n\n  allLanes.forEach(function(other) {\n\n    if (other === shape) {\n      return;\n    }\n\n    var topResize = 0,\n        rightResize = trblResize.right,\n        bottomResize = 0,\n        leftResize = trblResize.left;\n\n    var otherTrbl = asTRBL(other);\n\n    if (trblResize.top) {\n      if (abs(otherTrbl.bottom - shapeTrbl.top) < 10) {\n        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;\n      }\n\n      if (abs(otherTrbl.top - shapeTrbl.top) < 5) {\n        topResize = shapeNewTrbl.top - otherTrbl.top;\n      }\n    }\n\n    if (trblResize.bottom) {\n      if (abs(otherTrbl.top - shapeTrbl.bottom) < 10) {\n        topResize = shapeNewTrbl.bottom - otherTrbl.top;\n      }\n\n      if (abs(otherTrbl.bottom - shapeTrbl.bottom) < 5) {\n        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;\n      }\n    }\n\n    if (topResize || rightResize || bottomResize || leftResize) {\n\n      resizeNeeded.push({\n        shape: other,\n        newBounds: resizeTRBL(other, {\n          top: topResize,\n          right: rightResize,\n          bottom: bottomResize,\n          left: leftResize\n        })\n      });\n    }\n\n  });\n\n  return resizeNeeded;\n}\n\nmodule.exports.computeLanesResize = computeLanesResize;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/copy-paste/BpmnCopyPaste.js":"'use strict';\n\nvar ModelUtil = require('../../util/ModelUtil'),\n    getBusinessObject = ModelUtil.getBusinessObject,\n    is = ModelUtil.is;\n\nvar ModelCloneHelper = require('../../util/model/ModelCloneHelper');\n\nvar ModelCloneUtils = require('../../util/model/ModelCloneUtils'),\n    getProperties = ModelCloneUtils.getProperties;\n\nvar IGNORED_PROPERTIES = ModelCloneUtils.IGNORED_PROPERTIES;\n\nvar filter = require('lodash/collection/filter'),\n    forEach = require('lodash/collection/forEach');\n\nfunction setProperties(descriptor, data, properties) {\n  forEach(properties, function(property) {\n    if (data[property] !== undefined) {\n      descriptor[property] = data[property];\n    }\n  });\n}\n\nfunction removeProperties(element, properties) {\n  forEach(properties, function(prop) {\n    if (element[prop]) {\n      delete element[prop];\n    }\n  });\n}\n\nfunction BpmnCopyPaste(bpmnFactory, eventBus, copyPaste, clipboard, moddle, canvas, bpmnRules) {\n\n  var helper = new ModelCloneHelper(eventBus);\n\n  copyPaste.registerDescriptor(function(element, descriptor) {\n    var businessObject = getBusinessObject(element),\n        newBusinessObject = bpmnFactory.create(businessObject.$type);\n\n    var properties = getProperties(businessObject.$descriptor),\n        colors = {};\n\n    properties = filter(properties, function(property) {\n      return IGNORED_PROPERTIES.indexOf(property.replace(/bpmn:/, '')) === -1;\n    });\n\n    descriptor.businessObject = helper.clone(businessObject, newBusinessObject, properties);\n\n    descriptor.type = element.type;\n\n    setProperties(descriptor, businessObject.di, [ 'isExpanded' ]);\n\n    setProperties(colors, businessObject.di, [ 'fill', 'stroke' ]);\n\n    descriptor.colors = colors;\n\n    if (element.type === 'label') {\n      return descriptor;\n    }\n\n    setProperties(descriptor, businessObject, [\n      'type',\n      'processRef',\n      'triggeredByEvent'\n    ]);\n\n    if (businessObject.default) {\n      descriptor.default = businessObject.default.id;\n    }\n\n    return descriptor;\n  });\n\n  eventBus.on('element.paste', function(context) {\n    var descriptor = context.descriptor,\n        createdElements = context.createdElements,\n        parent = descriptor.parent,\n        rootElement = canvas.getRootElement(),\n        businessObject,\n        source,\n        target,\n        canConnect;\n\n    if (descriptor.type === 'label') {\n      return;\n    }\n\n    if (is(parent, 'bpmn:Process')) {\n      descriptor.parent = is(rootElement, 'bpmn:Collaboration') ? rootElement : parent;\n    }\n\n    if (descriptor.type === 'bpmn:DataOutputAssociation' ||\n        descriptor.type === 'bpmn:DataInputAssociation' ||\n        descriptor.type === 'bpmn:MessageFlow') {\n      descriptor.parent = rootElement;\n    }\n\n    if (is(parent, 'bpmn:Lane')) {\n      descriptor.parent = parent.parent;\n    }\n\n    // make sure that the correct type of connection is created\n    if (descriptor.waypoints) {\n      source = createdElements[descriptor.source];\n      target = createdElements[descriptor.target];\n\n      if (source && target) {\n        source = source.element;\n        target = target.element;\n      }\n\n      canConnect = bpmnRules.canConnect(source, target);\n\n      if (canConnect) {\n        descriptor.type = canConnect.type;\n      }\n    }\n\n    businessObject = descriptor.businessObject;\n\n    // remove the id or else we cannot paste multiple times\n    delete businessObject.id;\n\n    // assign an ID\n    bpmnFactory._ensureId(businessObject);\n\n    if (descriptor.type === 'bpmn:Participant' && descriptor.processRef) {\n      descriptor.processRef = businessObject.processRef = bpmnFactory.create('bpmn:Process');\n    }\n\n    setProperties(businessObject, descriptor, [\n      'isExpanded',\n      'triggeredByEvent'\n    ]);\n\n    removeProperties(descriptor, [\n      'triggeredByEvent'\n    ]);\n  });\n}\n\n\nBpmnCopyPaste.$inject = [\n  'bpmnFactory',\n  'eventBus',\n  'copyPaste',\n  'clipboard',\n  'moddle',\n  'canvas',\n  'bpmnRules'\n];\n\nmodule.exports = BpmnCopyPaste;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/util/model/ModelCloneHelper.js":"'use strict';\n\nvar forEach = require('lodash/collection/forEach'),\n    filter = require('lodash/collection/filter'),\n    any = require('lodash/collection/any'),\n    sort = require('lodash/collection/sortBy'),\n    isArray = require('lodash/lang/isArray');\n\nvar IGNORED_PROPERTIES = require('./ModelCloneUtils').IGNORED_PROPERTIES;\n\nfunction isAllowedIn(extProp, type) {\n  var allowedIn = extProp.meta.allowedIn;\n\n  // '*' is a wildcard, which means any element is allowed to use this property\n  if (allowedIn.length === 1 && allowedIn[0] === '*') {\n    return true;\n  }\n\n  return allowedIn.indexOf(type) !== -1;\n}\n\nfunction isType(element, types) {\n  return any(types, function(type) {\n    return typeof element === type;\n  });\n}\n\n/**\n * A bpmn properties cloning interface\n *\n */\nfunction ModelCloneHelper(eventBus) {\n  this._eventBus = eventBus;\n}\n\nmodule.exports = ModelCloneHelper;\n\n\nModelCloneHelper.prototype.clone = function(refElement, newElement, properties) {\n  // hasNestedProperty: property allows us to avoid ending up with empty (xml) tags\n  // f.ex: if extensionElements.values is empty, don't set it\n  var context = {\n    newElement: newElement,\n    hasNestedProperty: false\n  };\n\n  // we want the extensionElements to be cloned last\n  // so that they can check certain properties\n  properties = sort(properties, function(prop) {\n    return prop === 'bpmn:extensionElements';\n  });\n\n  forEach(properties, function(propName) {\n    var refElementProp = refElement.get(propName),\n        newElementProp = newElement.get(propName),\n        propDescriptor = newElement.$model.getPropertyDescriptor(newElement, propName),\n        newProperty, name;\n\n    // we're not interested in cloning:\n    // - same values from simple types\n    // - cloning id's\n    // - cloning reference elements\n    if (newElementProp === refElementProp ||\n       (propDescriptor && (propDescriptor.isId || propDescriptor.isReference))) {\n      return;\n    }\n\n    // if the property is of type 'boolean', 'string', 'number' or 'null', just set it\n    if (isType(refElementProp, [ 'boolean', 'string', 'number' ]) || refElementProp === null) {\n      newElement.set(propName, refElementProp);\n\n      return;\n    }\n\n    if (isArray(refElementProp)) {\n\n      forEach(refElementProp, function(extElement) {\n        var newProp;\n\n        context.refTopLevelProperty = extElement;\n\n        newProp = this._deepClone(extElement, context);\n\n        if (context.hasNestedProperty) {\n          newProp.$parent = newElement;\n\n          newElementProp.push(newProp);\n        }\n\n        context.hasNestedProperty = false;\n      }, this);\n\n    } else {\n      name = propName.replace(/bpmn:/, '');\n\n      context.refTopLevelProperty = refElementProp;\n\n      newProperty = this._deepClone(refElementProp, context);\n\n      if (context.hasNestedProperty) {\n        newElement[name] = newProperty;\n      }\n\n      context.hasNestedProperty = false;\n    }\n  }, this);\n\n  return newElement;\n};\n\nModelCloneHelper.prototype._deepClone = function _deepClone(propertyElement, context) {\n  var eventBus = this._eventBus;\n\n  var newProp = propertyElement.$model.create(propertyElement.$type);\n\n  var properties = filter(Object.keys(propertyElement), function(prop) {\n    var descriptor = newProp.$model.getPropertyDescriptor(newProp, prop);\n\n    if (descriptor && (descriptor.isId || descriptor.isReference)) {\n      return false;\n    }\n\n    // we need to make sure we don't clone certain properties\n    // which we cannot easily know if they hold references or not\n    if (IGNORED_PROPERTIES.indexOf(prop) !== -1) {\n      return false;\n    }\n\n    // make sure we don't copy the type\n    return prop !== '$type';\n  });\n\n  if (!properties.length) {\n    context.hasNestedProperty = true;\n  }\n\n  forEach(properties, function(propName) {\n    // check if the propertyElement has this property defined\n    if (propertyElement[propName] !== undefined &&\n       (propertyElement[propName].$type || isArray(propertyElement[propName]))) {\n\n      if (isArray(propertyElement[propName])) {\n        newProp[propName] = [];\n\n        forEach(propertyElement[propName], function(property) {\n          var extProp = propertyElement.$model.getTypeDescriptor(property.$type),\n              newDeepProp;\n\n          // we're not going to copy undefined types\n          if (!extProp) {\n            return;\n          }\n\n          var canClone = eventBus.fire('property.clone', {\n            newElement: context.newElement,\n            refTopLevelProperty: context.refTopLevelProperty,\n            propertyDescriptor: extProp\n          });\n\n          if (!canClone) {\n            // if can clone is 'undefined' or 'false'\n            // check for the meta information if it is allowed\n            if (propertyElement.$type === 'bpmn:ExtensionElements' &&\n                extProp.meta && extProp.meta.allowedIn &&\n                !isAllowedIn(extProp, context.newElement.$type)) {\n              return false;\n            }\n          }\n\n          newDeepProp = this._deepClone(property, context);\n\n          newDeepProp.$parent = newProp;\n\n          if (!newProp[propName]) {\n            newProp[propName] = [];\n          }\n\n          context.hasNestedProperty = true;\n\n          newProp[propName].push(newDeepProp);\n        }, this);\n\n      } else if (propertyElement[propName].$type) {\n        newProp[propName] = this._deepClone(propertyElement[propName], context);\n\n        if (newProp[propName]) {\n          context.hasNestedProperty = true;\n\n          newProp[propName].$parent = newProp;\n        }\n      }\n    } else {\n      context.hasNestedProperty = true;\n\n      // just assign directly if it's a value\n      newProp[propName] = propertyElement[propName];\n    }\n  }, this);\n\n  return newProp;\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/util/model/ModelCloneUtils.js":"'use strict';\n\nvar forEach = require('lodash/collection/forEach');\n\n/**\n * These are the properties that should be ignored when cloning elements.\n *\n * @type {Array}\n */\nmodule.exports.IGNORED_PROPERTIES = [\n  'lanes',\n  'incoming',\n  'outgoing',\n  'artifacts',\n  'default',\n  'flowElements'\n];\n\n\nfunction getProperties(descriptor, keepDefault) {\n  var properties = [];\n\n  forEach(descriptor.properties, function(property) {\n\n    if (keepDefault && property.default) {\n      return;\n    }\n\n    properties.push(property.ns.name);\n  });\n\n  return properties;\n}\n\nmodule.exports.getProperties = getProperties;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/distribute-elements/BpmnDistributeElements.js":"'use strict';\n\nvar filter = require('lodash/collection/filter');\n\nvar isAny = require('../modeling/util/ModelingUtil').isAny;\n\n/**\n * Registers element exclude filters for elements that currently do \n * not support distribution.\n */\nfunction BpmnDistributeElements(distributeElements) {\n\n  distributeElements.registerFilter(function(elements) {\n    return filter(elements, function(element) {\n      var cannotDistribute = isAny(element, [\n        'bpmn:Association',\n        'bpmn:BoundaryEvent',\n        'bpmn:DataInputAssociation',\n        'bpmn:DataOutputAssociation',\n        'bpmn:Lane',\n        'bpmn:MessageFlow',\n        'bpmn:Participant',\n        'bpmn:SequenceFlow',\n        'bpmn:TextAnnotation'\n      ]);\n\n      return !(element.labelTarget || cannotDistribute);\n    });\n  });\n}\n\nBpmnDistributeElements.$inject = [ 'distributeElements' ];\n\nmodule.exports = BpmnDistributeElements;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/editor-actions/BpmnEditorActions.js":"'use strict';\n\nvar inherits = require('inherits');\n\nvar EditorActions = require('diagram-js/lib/features/editor-actions/EditorActions');\n\nvar filter = require('lodash/collection/filter');\n\nvar is = require('../../util/ModelUtil').is;\n\nvar getBBox = require('diagram-js/lib/util/Elements').getBBox;\n\nfunction BpmnEditorActions(\n    injector,\n    canvas, elementRegistry, selection,\n    spaceTool,\n    lassoTool,\n    handTool,\n    globalConnect,\n    distributeElements,\n    alignElements,\n    directEditing,\n    searchPad,\n    modeling) {\n\n  injector.invoke(EditorActions, this);\n\n  this.register({\n    selectElements: function() {\n      // select all elements except for the invisible\n      // root element\n      var rootElement = canvas.getRootElement();\n\n      var elements = elementRegistry.filter(function(element) {\n        return element !== rootElement;\n      });\n\n      selection.select(elements);\n\n      return elements;\n    },\n    spaceTool: function() {\n      spaceTool.toggle();\n    },\n    lassoTool: function() {\n      lassoTool.toggle();\n    },\n    handTool: function() {\n      handTool.toggle();\n    },\n    globalConnectTool: function() {\n      globalConnect.toggle();\n    },\n    distributeElements: function(opts) {\n      var currentSelection = selection.get(),\n          type = opts.type;\n\n      if (currentSelection.length) {\n        distributeElements.trigger(currentSelection, type);\n      }\n    },\n    alignElements: function(opts) {\n      var currentSelection = selection.get(),\n          aligneableElements = [],\n          type = opts.type;\n\n      if (currentSelection.length) {\n        aligneableElements = filter(currentSelection, function(element) {\n          return !is(element, 'bpmn:Lane');\n        });\n\n        alignElements.trigger(aligneableElements, type);\n      }\n    },\n    setColor: function(opts) {\n      var currentSelection = selection.get();\n\n      if (currentSelection.length) {\n        modeling.setColor(currentSelection, opts);\n      }\n    },\n    directEditing: function() {\n      var currentSelection = selection.get();\n\n      if (currentSelection.length) {\n        directEditing.activate(currentSelection[0]);\n      }\n    },\n    find: function() {\n      searchPad.toggle();\n    },\n    moveToOrigin: function() {\n      var rootElement = canvas.getRootElement(),\n          boundingBox,\n          elements;\n\n      if (is(rootElement, 'bpmn:Collaboration')) {\n        elements = elementRegistry.filter(function(element) {\n          return is(element.parent, 'bpmn:Collaboration');\n        });\n      } else {\n        elements = elementRegistry.filter(function(element) {\n          return element !== rootElement && !is(element.parent, 'bpmn:SubProcess');\n        });\n      }\n\n      boundingBox = getBBox(elements);\n\n      modeling.moveElements(elements, { x: -boundingBox.x, y: -boundingBox.y }, rootElement);\n    }\n  });\n}\n\ninherits(BpmnEditorActions, EditorActions);\n\nBpmnEditorActions.$inject = [\n  'injector',\n  'canvas', 'elementRegistry', 'selection',\n  'spaceTool',\n  'lassoTool',\n  'handTool',\n  'globalConnect',\n  'distributeElements',\n  'alignElements',\n  'directEditing',\n  'searchPad',\n  'modeling'\n];\n\nmodule.exports = BpmnEditorActions;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/global-connect/BpmnGlobalConnect.js":"'use strict';\n\nvar isAny = require('../modeling/util/ModelingUtil').isAny;\n\n/**\n * Extention of GlobalConnect tool that implements BPMN specific rules about\n * connection start elements.\n */\nfunction BpmnGlobalConnect(globalConnect) {\n  globalConnect.registerProvider(this);\n}\n\nBpmnGlobalConnect.$inject = [ 'globalConnect' ];\n\nmodule.exports = BpmnGlobalConnect;\n\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n * @return {Boolean}\n */\nBpmnGlobalConnect.prototype.canStartConnect = function(source) {\n\n  if (nonExistantOrLabel(source)) {\n    return null;\n  }\n\n  var businessObject = source.businessObject;\n\n  return isAny(businessObject, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ]);\n};\n\n\nfunction nonExistantOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isLabel(element) {\n  return element.labelTarget;\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/keyboard/BpmnKeyBindings.js":"'use strict';\n\n/**\n * BPMN 2.0 specific key bindings.\n *\n * @param {Keyboard} keyboard\n * @param {EditorActions} editorActions\n */\nfunction BpmnKeyBindings(keyboard, editorActions) {\n\n  keyboard.addListener(function(key, modifiers) {\n\n    // ctrl + a -> select all elements\n    if (key === 65 && keyboard.isCmd(modifiers)) {\n      editorActions.trigger('selectElements');\n\n      return true;\n    }\n\n    // ctrl + f -> search labels\n    if (key === 70 && keyboard.isCmd(modifiers)) {\n      editorActions.trigger('find');\n\n      return true;\n    }\n\n    if (keyboard.hasModifier(modifiers)) {\n      return;\n    }\n\n    // s -> activate space tool\n    if (key === 83) {\n      editorActions.trigger('spaceTool');\n\n      return true;\n    }\n\n    // l -> activate lasso tool\n    if (key === 76) {\n      editorActions.trigger('lassoTool');\n\n      return true;\n    }\n\n    // h -> activate hand tool\n    if (key === 72) {\n      editorActions.trigger('handTool');\n\n      return true;\n    }\n\n    // c -> activate global connect tool\n    if (key === 67) {\n      editorActions.trigger('globalConnectTool');\n\n      return true;\n    }\n\n    // e -> activate direct editing\n    if (key === 69) {\n      editorActions.trigger('directEditing');\n\n      return true;\n    }\n  });\n}\n\nBpmnKeyBindings.$inject = [\n  'keyboard',\n  'editorActions'\n];\n\nmodule.exports = BpmnKeyBindings;","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/label-editing/LabelEditingProvider.js":"'use strict';\n\nvar UpdateLabelHandler = require('./cmd/UpdateLabelHandler');\n\nvar LabelUtil = require('./LabelUtil');\n\nvar is = require('../../util/ModelUtil').is,\n    isExpanded = require('../../util/DiUtil').isExpanded;\n\nvar LINE_HEIGHT = 14,\n    PADDING = 6;\n\nfunction LabelEditingProvider(eventBus, canvas, directEditing, commandStack) {\n\n  this._canvas = canvas;\n  this._commandStack = commandStack;\n\n  directEditing.registerProvider(this);\n\n  commandStack.registerHandler('element.updateLabel', UpdateLabelHandler);\n\n  // listen to dblclick on non-root elements\n  eventBus.on('element.dblclick', function(event) {\n    directEditing.activate(event.element);\n  });\n\n  // complete on followup canvas operation\n  eventBus.on([ 'element.mousedown', 'drag.init', 'canvas.viewbox.changed' ], function(event) {\n    directEditing.complete();\n  });\n\n  // cancel on command stack changes\n  eventBus.on([ 'commandStack.changed' ], function() {\n    directEditing.cancel();\n  });\n\n\n  if ('ontouchstart' in document.documentElement) {\n    // we deactivate automatic label editing on mobile devices\n    // as it breaks the user interaction workflow\n\n    // TODO(nre): we should temporarily focus the edited element here\n    // and release the focused viewport after the direct edit operation is finished\n  } else {\n    eventBus.on('create.end', 500, function(e) {\n\n      var element = e.shape,\n          canExecute = e.context.canExecute;\n\n      if (!canExecute) {\n        return;\n      }\n\n      if (is(element, 'bpmn:Task') || is(element, 'bpmn:TextAnnotation') ||\n          (is(element, 'bpmn:SubProcess') && !isExpanded(element))) {\n\n        directEditing.activate(element);\n      }\n    });\n  }\n}\n\nLabelEditingProvider.$inject = [ 'eventBus', 'canvas', 'directEditing', 'commandStack' ];\n\nmodule.exports = LabelEditingProvider;\n\n\n/**\n * Activate direct editing for activities and text annotations.\n *\n * @param  {djs.model.Base} element\n *\n * @return {Object} an object with properties bounds (position and size) and text\n */\nLabelEditingProvider.prototype.activate = function(element) {\n\n  var text = LabelUtil.getLabel(element);\n\n  if (text === undefined) {\n    return;\n  }\n\n  var properties = this.getEditingBBox(element);\n\n  properties.text = text;\n\n  return properties;\n};\n\n\n/**\n * Get the editing bounding box based on the element's size and position\n *\n * @param  {djs.model.Base} element\n *\n * @return {Object} an object containing information about position and size (fixed or minimum and/or maximum)\n */\nLabelEditingProvider.prototype.getEditingBBox = function(element) {\n  var canvas = this._canvas;\n\n  var target = element.label || element;\n\n  var bbox = canvas.getAbsoluteBBox(target);\n\n  var mid = {\n    x: bbox.x + bbox.width / 2,\n    y: bbox.y + bbox.height / 2\n  };\n\n  // default position\n  var bounds = { x: bbox.x, y: bbox.y };\n\n  var style = {},\n      zoom;\n\n  // adjust for expanded pools AND lanes\n  if ((is(element, 'bpmn:Participant') && isExpanded(element)) || is(element, 'bpmn:Lane')) {\n\n    bounds.width = 150;\n    bounds.minHeight = LINE_HEIGHT + PADDING;\n    bounds.maxHeight = LINE_HEIGHT * 2 + PADDING;\n    bounds.x = bbox.x - bounds.width / 2;\n    bounds.y = mid.y - bounds.minHeight / 2;\n  }\n\n\n  // internal labels for tasks and collapsed call activities, sub processes and participants\n  if (\n    is(element, 'bpmn:Task') ||\n    (is(element, 'bpmn:CallActivity') && !isExpanded(element)) ||\n    (is(element, 'bpmn:SubProcess') && !isExpanded(element)) ||\n    (is(element, 'bpmn:Participant') && !isExpanded(element))\n  ) {\n\n    zoom = canvas.zoom();\n\n    // fixed size for internal labels:\n    // on high zoom levels: text box size === bbox size\n    // on low zoom levels: text box size === bbox size at 100% zoom\n    // This ensures minimum bounds at low zoom levels\n    if (zoom > 1) {\n      bounds.width = bbox.width;\n      bounds.height = bbox.height;\n    } else {\n      bounds.width = bbox.width / zoom;\n      bounds.height = bbox.height / zoom;\n    }\n\n    // centering overlapping text box size at low zoom levels\n    if (zoom < 1) {\n      bounds.x = bbox.x - (bounds.width / 2 - bbox.width / 2);\n      bounds.y = bbox.y - (bounds.height / 2 - bbox.height / 2);\n    }\n\n  }\n\n\n  // internal labels for expanded sub processes\n  if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {\n\n    bounds.width = element.width;\n    bounds.maxHeight = 3 * LINE_HEIGHT + PADDING; // maximum 3 lines\n    bounds.x = mid.x - element.width / 2;\n  }\n\n\n  // external labels for events, data elements, gateways and connections\n  if (target.labelTarget) {\n\n    bounds.width = 150;\n    bounds.minHeight = LINE_HEIGHT + PADDING; // 1 line\n    bounds.x = mid.x - bounds.width / 2;\n  }\n\n\n  // text annotations\n  if (is(element, 'bpmn:TextAnnotation')) {\n    bounds.minWidth = 100;\n    bounds.height = element.height;\n\n    style.textAlign = 'left';\n  }\n\n  return { bounds: bounds, style: style };\n};\n\n\nLabelEditingProvider.prototype.update = function(element, newLabel) {\n  this._commandStack.execute('element.updateLabel', {\n    element: element,\n    newLabel: newLabel\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/label-editing/cmd/UpdateLabelHandler.js":"'use strict';\n\nvar LabelUtil = require('../LabelUtil');\n\nvar TextUtil = require('diagram-js/lib/util/Text');\n\nvar hasExternalLabel = require('../../../util/LabelUtil').hasExternalLabel;\n\nvar getBusinessObject = require('../../../util/ModelUtil').getBusinessObject;\n\nvar NULL_DIMENSIONS = {\n  width: 0,\n  height: 0\n};\n\n\n/**\n * A handler that updates the text of a BPMN element.\n */\nfunction UpdateLabelHandler(modeling) {\n\n  var textUtil = new TextUtil();\n\n  /**\n   * Set the label and return the changed elements.\n   *\n   * Element parameter can be label itself or connection (i.e. sequence flow).\n   *\n   * @param {djs.model.Base} element\n   * @param {String} text\n   */\n  function setText(element, text) {\n\n    // external label if present\n    var label = element.label || element;\n\n    var labelTarget = element.labelTarget || element;\n\n    LabelUtil.setLabel(label, text, labelTarget !== label);\n\n    return [ label, labelTarget ];\n  }\n\n  function execute(ctx) {\n    ctx.oldLabel = LabelUtil.getLabel(ctx.element);\n    return setText(ctx.element, ctx.newLabel);\n  }\n\n  function revert(ctx) {\n    return setText(ctx.element, ctx.oldLabel);\n  }\n\n  function postExecute(ctx) {\n    var element = ctx.element,\n        label = element.label || element;\n\n    // ignore internal labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var text = getBusinessObject(label).name;\n\n    if (!text) {\n      return;\n    }\n\n    // get layouted text bounds and resize external\n    // external label accordingly\n    var newBounds = getLayoutedBounds(label, text, textUtil);\n\n    modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);\n  }\n\n  // API\n\n  this.execute = execute;\n  this.revert = revert;\n  this.postExecute = postExecute;\n}\n\nUpdateLabelHandler.$inject = [ 'modeling' ];\n\nmodule.exports = UpdateLabelHandler;\n\n\n// TODO(nikku): repeating code (search for <getLayoutedBounds>)\n\nvar EXTERNAL_LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: '11px'\n};\n\nfunction getLayoutedBounds(bounds, text, textUtil) {\n\n  var layoutedLabelDimensions = textUtil.getDimensions(text, {\n    box: {\n      width: 90,\n      height: 30,\n      x: bounds.width / 2 + bounds.x,\n      y: bounds.height / 2 + bounds.y\n    },\n    style: EXTERNAL_LABEL_STYLE\n  });\n\n  // resize label shape to fit label text\n  return {\n    x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),\n    y: Math.round(bounds.y),\n    width: Math.ceil(layoutedLabelDimensions.width),\n    height: Math.ceil(layoutedLabelDimensions.height)\n  };\n}","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js":"'use strict';\n\nvar is = require('../../util/ModelUtil').is;\n\nfunction getLabelAttr(semantic) {\n  if (is(semantic, 'bpmn:FlowElement') ||\n      is(semantic, 'bpmn:Participant') ||\n      is(semantic, 'bpmn:Lane') ||\n      is(semantic, 'bpmn:SequenceFlow') ||\n      is(semantic, 'bpmn:MessageFlow')) {\n\n    return 'name';\n  }\n\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return 'text';\n  }\n}\n\nmodule.exports.getLabel = function(element) {\n  var semantic = element.businessObject,\n      attr = getLabelAttr(semantic);\n\n  if (attr) {\n    return semantic[attr] || '';\n  }\n};\n\n\nmodule.exports.setLabel = function(element, text, isExternal) {\n  var semantic = element.businessObject,\n      attr = getLabelAttr(semantic);\n\n  if (attr) {\n    semantic[attr] = text;\n  }\n\n  // show external label if not empty\n  if (isExternal) {\n    element.hidden = !text;\n  }\n\n  return element;\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/BpmnFactory.js":"'use strict';\n\nvar map = require('lodash/collection/map'),\n    assign = require('lodash/object/assign'),\n    pick = require('lodash/object/pick');\n\n\nfunction BpmnFactory(moddle) {\n  this._model = moddle;\n}\n\nBpmnFactory.$inject = [ 'moddle' ];\n\n\nBpmnFactory.prototype._needsId = function(element) {\n  return element.$instanceOf('bpmn:RootElement') ||\n         element.$instanceOf('bpmn:FlowElement') ||\n         element.$instanceOf('bpmn:MessageFlow') ||\n         element.$instanceOf('bpmn:DataAssociation') ||\n         element.$instanceOf('bpmn:Artifact') ||\n         element.$instanceOf('bpmn:Participant') ||\n         element.$instanceOf('bpmn:Lane') ||\n         element.$instanceOf('bpmn:Process') ||\n         element.$instanceOf('bpmn:Collaboration') ||\n         element.$instanceOf('bpmndi:BPMNShape') ||\n         element.$instanceOf('bpmndi:BPMNEdge') ||\n         element.$instanceOf('bpmndi:BPMNDiagram') ||\n         element.$instanceOf('bpmndi:BPMNPlane') ||\n         element.$instanceOf('bpmn:Property');\n};\n\nBpmnFactory.prototype._ensureId = function(element) {\n\n  // generate semantic ids for elements\n  // bpmn:SequenceFlow -> SequenceFlow_ID\n  var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';\n\n  if (!element.id && this._needsId(element)) {\n    element.id = this._model.ids.nextPrefixed(prefix, element);\n  }\n};\n\n\nBpmnFactory.prototype.create = function(type, attrs) {\n  var element = this._model.create(type, attrs || {});\n\n  this._ensureId(element);\n\n  return element;\n};\n\n\nBpmnFactory.prototype.createDiLabel = function() {\n  return this.create('bpmndi:BPMNLabel', {\n    bounds: this.createDiBounds()\n  });\n};\n\n\nBpmnFactory.prototype.createDiShape = function(semantic, bounds, attrs) {\n\n  return this.create('bpmndi:BPMNShape', assign({\n    bpmnElement: semantic,\n    bounds: this.createDiBounds(bounds)\n  }, attrs));\n};\n\n\nBpmnFactory.prototype.createDiBounds = function(bounds) {\n  return this.create('dc:Bounds', bounds);\n};\n\n\nBpmnFactory.prototype.createDiWaypoints = function(waypoints) {\n  return map(waypoints, function(pos) {\n    return this.createDiWaypoint(pos);\n  }, this);\n};\n\nBpmnFactory.prototype.createDiWaypoint = function(point) {\n  return this.create('dc:Point', pick(point, [ 'x', 'y' ]));\n};\n\n\nBpmnFactory.prototype.createDiEdge = function(semantic, waypoints, attrs) {\n  return this.create('bpmndi:BPMNEdge', assign({\n    bpmnElement: semantic\n  }, attrs));\n};\n\nBpmnFactory.prototype.createDiPlane = function(semantic) {\n  return this.create('bpmndi:BPMNPlane', {\n    bpmnElement: semantic\n  });\n};\n\nmodule.exports = BpmnFactory;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js":"'use strict';\n\nvar inherits = require('inherits');\n\nvar assign = require('lodash/object/assign');\n\nvar BaseLayouter = require('diagram-js/lib/layout/BaseLayouter'),\n    ManhattanLayout = require('diagram-js/lib/layout/ManhattanLayout');\n\nvar LayoutUtil = require('diagram-js/lib/layout/LayoutUtil');\n\nvar isExpanded = require('../../util/DiUtil').isExpanded;\n\nvar getMid = LayoutUtil.getMid,\n    getOrientation = LayoutUtil.getOrientation;\n\nvar is = require('../../util/ModelUtil').is;\n\n\nfunction BpmnLayouter() {}\n\ninherits(BpmnLayouter, BaseLayouter);\n\nmodule.exports = BpmnLayouter;\n\n\nBpmnLayouter.prototype.layoutConnection = function(connection, hints) {\n\n  hints = hints || {};\n\n  var source = connection.source,\n      target = connection.target,\n      waypoints = connection.waypoints,\n      start = hints.connectionStart,\n      end = hints.connectionEnd;\n\n  var manhattanOptions,\n      updatedWaypoints;\n\n  if (!start) {\n    start = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n\n  if (!end) {\n    end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  }\n\n  // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n  if (is(connection, 'bpmn:Association') ||\n      is(connection, 'bpmn:DataAssociation')) {\n\n    if (waypoints && !isCompensationAssociation(connection)) {\n      return [].concat([ start ], waypoints.slice(1, -1), [ end ]);\n    }\n  }\n\n  // manhattan layout sequence / message flows\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = {\n      preferredLayouts: [ 'v:v' ]\n    };\n\n    if (is(target, 'bpmn:Participant')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ]\n      };\n    }\n\n    if (isExpandedSubProcess(target)) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ]\n      };\n    }\n\n    if (isExpandedSubProcess(source) && is(target, 'bpmn:FlowNode')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ],\n        preserveDocking: isExpandedSubProcess(target) ? 'source' : 'target'\n      };\n    }\n\n    if (is(source, 'bpmn:Participant') && is(target, 'bpmn:FlowNode')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ],\n        preserveDocking: 'target'\n      };\n    }\n\n    if (is(target, 'bpmn:Event')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'v:v' ]\n      };\n    }\n  } else\n\n\n  // layout all connection between flow elements h:h,\n  //\n  // except for\n  //\n  // (1) outgoing of BoundaryEvents -> layout h:v or v:h based on attach orientation\n  // (2) incoming / outgoing of Gateway -> v:h (outgoing), h:v (incoming)\n  //\n  if (is(connection, 'bpmn:SequenceFlow') ||\n      isCompensationAssociation(connection)) {\n\n    // make sure boundary event connections do\n    // not look ugly =:>\n    if (is(source, 'bpmn:BoundaryEvent')) {\n\n      var orientation = getAttachOrientation(source);\n\n      if (/left|right/.test(orientation)) {\n        manhattanOptions = {\n          preferredLayouts: [ 'h:v' ]\n        };\n      } else\n\n      if (/top|bottom/.test(orientation)) {\n        manhattanOptions = {\n          preferredLayouts: [ 'v:h' ]\n        };\n      }\n    } else\n\n    if (is(source, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'v:h' ]\n      };\n    } else\n\n    if (is(target, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'h:v' ]\n      };\n    }\n\n    // apply horizontal love <3\n    else {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:h' ]\n      };\n    }\n  }\n\n  if (manhattanOptions) {\n\n    manhattanOptions = assign(manhattanOptions, hints);\n\n    updatedWaypoints =\n      ManhattanLayout.repairConnection(\n        source, target,\n        start, end,\n        waypoints,\n        manhattanOptions);\n  }\n\n  return updatedWaypoints || [ start, end ];\n};\n\n\nfunction getAttachOrientation(attachedElement) {\n\n  var hostElement = attachedElement.host,\n      padding = -10;\n\n  return getOrientation(getMid(attachedElement), hostElement, padding);\n}\n\n\nfunction getConnectionDocking(point, shape) {\n  return point ? (point.original || point) : getMid(shape);\n}\n\nfunction isCompensationAssociation(connection) {\n\n  var source = connection.source,\n      target = connection.target;\n\n  return is(target, 'bpmn:Activity') &&\n         is(source, 'bpmn:BoundaryEvent') &&\n         target.businessObject.isForCompensation;\n}\n\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js":"'use strict';\n\nvar assign = require('lodash/object/assign'),\n    forEach = require('lodash/collection/forEach'),\n    inherits = require('inherits');\n\nvar Collections = require('diagram-js/lib/util/Collections'),\n    Model = require('diagram-js/lib/model');\n\nvar getBusinessObject = require('../../util/ModelUtil').getBusinessObject,\n    is = require('../../util/ModelUtil').is;\n\nvar CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\nfunction BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n\n  var self = this;\n\n\n\n  ////// connection cropping /////////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n        connection;\n\n    if (!context.cropped) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.create',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], cropConnection);\n\n  this.reverted([ 'connection.layout' ], function(e) {\n    delete e.context.cropped;\n  });\n\n\n\n  ////// BPMN + DI update /////////////////////////\n\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n        // oldParent is the (old) new parent, because we are undoing\n        oldParent = context.parent || context.newParent;\n\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed([ 'shape.move',\n                  'shape.create',\n                  'shape.delete',\n                  'connection.create',\n                  'connection.move',\n                  'connection.delete' ], ifBpmn(updateParent));\n\n  this.reverted([ 'shape.move',\n                  'shape.create',\n                  'shape.delete',\n                  'connection.create',\n                  'connection.move',\n                  'connection.delete' ], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n\n    forEach(children, function(child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\n\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function(event) {\n    if (event.element.type === 'label') {\n      updateBounds({ context: { shape: event.element } });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n  this.reverted([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnectionWaypoints));\n\n  this.reverted([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnectionWaypoints));\n\n\n  // update Default & Conditional flows\n  this.executed([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        oldSource = getBusinessObject(context.oldSource),\n        oldTarget = getBusinessObject(context.oldTarget),\n        newSource = getBusinessObject(connection.source),\n        newTarget = getBusinessObject(connection.target);\n\n    if (oldSource === newSource || oldTarget === newTarget) {\n      return;\n    }\n\n    // on reconnectStart -> default flow\n    if (oldSource && oldSource.default === businessObject) {\n      context.default = oldSource.default;\n      oldSource.default = undefined;\n    }\n\n    // on reconnectEnd -> default flow\n    if ((businessObject.sourceRef && businessObject.sourceRef.default) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent')) ) {\n      context.default = businessObject.sourceRef.default;\n      businessObject.sourceRef.default = undefined;\n    }\n\n    // on reconnectStart -> conditional flow\n    if (oldSource && (businessObject.conditionExpression) &&\n      !(is(newSource, 'bpmn:Activity') ||\n        is(newSource, 'bpmn:Gateway')) ) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n\n    // on reconnectEnd -> conditional flow\n    if (oldTarget && (businessObject.conditionExpression) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent')) ) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n  }));\n\n  this.reverted([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        newSource = getBusinessObject(connection.source);\n\n    // default flow\n    if (context.default) {\n      if (is(newSource, 'bpmn:ExclusiveGateway') || is(newSource, 'bpmn:InclusiveGateway') ||\n          is(newSource, 'bpmn:Activity')) {\n        newSource.default = context.default;\n      }\n    }\n\n    // conditional flow\n    if (context.conditionExpression && is(newSource, 'bpmn:Activity')) {\n      businessObject.conditionExpression = context.conditionExpression;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n}\n\ninherits(BpmnUpdater, CommandInterceptor);\n\nmodule.exports = BpmnUpdater;\n\nBpmnUpdater.$inject = [ 'eventBus', 'bpmnFactory', 'connectionDocking', 'translate' ];\n\n\n/////// implementation //////////////////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function(context) {\n\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function(element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Model.Label) {\n    return;\n  }\n\n  var parentShape = element.parent;\n\n  var businessObject = element.businessObject,\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = parentBusinessObject && parentBusinessObject.di;\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(businessObject.di, parentDi);\n};\n\n\nBpmnUpdater.prototype.updateBounds = function(shape) {\n\n  var di = shape.businessObject.di;\n\n  var bounds = (shape instanceof Model.Label) ? this._getLabel(di).bounds : di.bounds;\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\n\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is (oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    Collections.remove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    Collections.add(newRefs, businessObject);\n  }\n};\n\n\n// update existing sourceElement and targetElement di information\nBpmnUpdater.prototype.updateDiConnection = function(di, newSource, newTarget) {\n\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n\n};\n\n\nBpmnUpdater.prototype.updateDiParent = function(di, parentDi) {\n\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    Collections.remove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function(container) {\n\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\n\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else\n\n  if (is(businessObject, 'bpmn:FlowElement')) {\n\n    if (newParent) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else\n\n      if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n\n      }\n    }\n\n    containment = 'flowElements';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Artifact')) {\n\n    while (newParent &&\n           !is(newParent, 'bpmn:Process') &&\n           !is(newParent, 'bpmn:SubProcess') &&\n           !is(newParent, 'bpmn:Collaboration')) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else\n\n  if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        Collections.remove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        Collections.add(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate(\n      'no parent for {element} in {parent}',\n      {\n        element: businessObject.id,\n        parent: newParent.id\n      }\n    ));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    Collections.remove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n\n    Collections.remove(children, businessObject);\n\n    if (newParent) {\n\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\n\nBpmnUpdater.prototype.updateConnection = function(context) {\n\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = getBusinessObject(connection.source),\n      newTarget = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        Collections.remove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSource;\n    }\n\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        Collections.remove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTarget;\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMany sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n\n    visualParent = context.parent || context.newParent || newTarget;\n\n    this.updateSemanticParent(businessObject, newTarget, parent.businessObject);\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n\n    this.updateSemanticParent(businessObject, newSource, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTarget;\n  }\n\n  this.updateConnectionWaypoints(connection);\n\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n};\n\n\n/////// helpers /////////////////////////////////////////\n\nBpmnUpdater.prototype._getLabel = function(di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n\n\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\nfunction ifBpmn(fn) {\n\n  return function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/ElementFactory.js":"'use strict';\n\nvar assign = require('lodash/object/assign'),\n    forEach = require('lodash/collection/forEach'),\n    inherits = require('inherits');\n\nvar is = require('../../util/ModelUtil').is;\n\nvar isExpanded = require('../../util/DiUtil').isExpanded;\n\nvar BaseElementFactory = require('diagram-js/lib/core/ElementFactory'),\n    LabelUtil = require('../../util/LabelUtil');\n\n/**\n * A bpmn-aware factory for diagram-js shapes\n */\nfunction ElementFactory(bpmnFactory, moddle, translate) {\n  BaseElementFactory.call(this);\n\n  this._bpmnFactory = bpmnFactory;\n  this._moddle = moddle;\n  this._translate = translate;\n}\n\ninherits(ElementFactory, BaseElementFactory);\n\n\nElementFactory.$inject = [ 'bpmnFactory', 'moddle', 'translate' ];\n\nmodule.exports = ElementFactory;\n\nElementFactory.prototype.baseCreate = BaseElementFactory.prototype.create;\n\nElementFactory.prototype.create = function(elementType, attrs) {\n  // no special magic for labels,\n  // we assume their businessObjects have already been created\n  // and wired via attrs\n  if (elementType === 'label') {\n    return this.baseCreate(elementType, assign({ type: 'label' }, LabelUtil.DEFAULT_LABEL_SIZE, attrs));\n  }\n\n  return this.createBpmnElement(elementType, attrs);\n};\n\nElementFactory.prototype.createBpmnElement = function(elementType, attrs) {\n  var size,\n      translate = this._translate;\n\n  attrs = attrs || {};\n\n  var businessObject = attrs.businessObject;\n\n  if (!businessObject) {\n    if (!attrs.type) {\n      throw new Error(translate('no shape type specified'));\n    }\n\n    businessObject = this._bpmnFactory.create(attrs.type);\n  }\n\n  if (!businessObject.di) {\n    if (elementType === 'root') {\n      businessObject.di = this._bpmnFactory.createDiPlane(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else\n    if (elementType === 'connection') {\n      businessObject.di = this._bpmnFactory.createDiEdge(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else {\n      businessObject.di = this._bpmnFactory.createDiShape(businessObject, {}, {\n        id: businessObject.id + '_di'\n      });\n    }\n  }\n\n  if (attrs.colors) {\n    assign(businessObject.di, attrs.colors);\n\n    delete attrs.colors;\n  }\n\n  applyAttributes(businessObject, attrs, [\n    'processRef',\n    'isInterrupting',\n    'associationDirection',\n    'isForCompensation'\n  ]);\n\n  if (attrs.isExpanded) {\n    applyAttribute(businessObject.di, attrs, 'isExpanded');\n  }\n\n  if (is(businessObject, 'bpmn:ExclusiveGateway')) {\n    businessObject.di.isMarkerVisible = true;\n  }\n\n  var eventDefinitions,\n      newEventDefinition;\n\n  if (attrs.eventDefinitionType) {\n    eventDefinitions = businessObject.get('eventDefinitions') || [];\n    newEventDefinition = this._moddle.create(attrs.eventDefinitionType);\n\n    eventDefinitions.push(newEventDefinition);\n\n    newEventDefinition.$parent = businessObject;\n    businessObject.eventDefinitions = eventDefinitions;\n\n    delete attrs.eventDefinitionType;\n  }\n\n  size = this._getDefaultSize(businessObject);\n\n  attrs = assign({\n    businessObject: businessObject,\n    id: businessObject.id\n  }, size, attrs);\n\n  return this.baseCreate(elementType, attrs);\n};\n\n\nElementFactory.prototype._getDefaultSize = function(semantic) {\n\n  if (is(semantic, 'bpmn:SubProcess')) {\n\n    if (isExpanded(semantic)) {\n      return { width: 350, height: 200 };\n    } else {\n      return { width: 100, height: 80 };\n    }\n  }\n\n  if (is(semantic, 'bpmn:Task')) {\n    return { width: 100, height: 80 };\n  }\n\n  if (is(semantic, 'bpmn:Gateway')) {\n    return { width: 50, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:Event')) {\n    return { width: 36, height: 36 };\n  }\n\n  if (is(semantic, 'bpmn:Participant')) {\n    if (!isExpanded(semantic)) {\n      return { width: 400, height: 100 };\n    } else {\n      return { width: 600, height: 250 };\n    }\n  }\n\n  if (is(semantic, 'bpmn:Lane')) {\n    return { width: 400, height: 100 };\n  }\n\n  if (is(semantic, 'bpmn:DataObjectReference')) {\n    return { width: 36, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:DataStoreReference')) {\n    return { width: 50, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return { width: 100, height: 30 };\n  }\n\n  return { width: 100, height: 80 };\n};\n\n\nElementFactory.prototype.createParticipantShape = function(collapsed) {\n\n  var attrs = { type: 'bpmn:Participant' };\n\n  if (!collapsed) {\n    attrs.processRef = this._bpmnFactory.create('bpmn:Process');\n  }\n\n  return this.createShape(attrs);\n};\n\n\n//////////// helpers ////////////////////////////////////\n\n/**\n * Apply attributes from a map to the given element,\n * remove attribute from the map on application.\n *\n * @param {Base} element\n * @param {Object} attrs (in/out map of attributes)\n * @param {Array<String>} attributeNames name of attributes to apply\n */\nfunction applyAttributes(element, attrs, attributeNames) {\n\n  forEach(attributeNames, function(property) {\n    if (attrs[property] !== undefined) {\n      applyAttribute(element, attrs, property);\n    }\n  });\n}\n\n/**\n * Apply named property to element and drain it from the attrs\n * collection.\n *\n * @param {Base} element\n * @param {Object} attrs (in/out map of attributes)\n * @param {String} attributeName to apply\n */\nfunction applyAttribute(element, attrs, attributeName) {\n  element[attributeName] = attrs[attributeName];\n\n  delete attrs[attributeName];\n}","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/Modeling.js":"'use strict';\n\nvar inherits = require('inherits');\n\nvar BaseModeling = require('diagram-js/lib/features/modeling/Modeling');\n\nvar UpdatePropertiesHandler = require('./cmd/UpdatePropertiesHandler'),\n    UpdateCanvasRootHandler = require('./cmd/UpdateCanvasRootHandler'),\n    AddLaneHandler = require('./cmd/AddLaneHandler'),\n    SplitLaneHandler = require('./cmd/SplitLaneHandler'),\n    ResizeLaneHandler = require('./cmd/ResizeLaneHandler'),\n    UpdateFlowNodeRefsHandler = require('./cmd/UpdateFlowNodeRefsHandler'),\n    IdClaimHandler = require('./cmd/IdClaimHandler'),\n    SetColorHandler = require('./cmd/SetColorHandler');\n\n\n/**\n * BPMN 2.0 modeling features activator\n *\n * @param {EventBus} eventBus\n * @param {ElementFactory} elementFactory\n * @param {CommandStack} commandStack\n * @param {BpmnRules} bpmnRules\n */\nfunction Modeling(eventBus, elementFactory, commandStack, bpmnRules) {\n  BaseModeling.call(this, eventBus, elementFactory, commandStack);\n\n  this._bpmnRules = bpmnRules;\n}\n\ninherits(Modeling, BaseModeling);\n\nModeling.$inject = [ 'eventBus', 'elementFactory', 'commandStack', 'bpmnRules' ];\n\nmodule.exports = Modeling;\n\n\nModeling.prototype.getHandlers = function() {\n  var handlers = BaseModeling.prototype.getHandlers.call(this);\n\n  handlers['element.updateProperties'] = UpdatePropertiesHandler;\n  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;\n  handlers['lane.add'] = AddLaneHandler;\n  handlers['lane.resize'] = ResizeLaneHandler;\n  handlers['lane.split'] = SplitLaneHandler;\n  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;\n  handlers['id.updateClaim'] = IdClaimHandler;\n  handlers['element.setColor'] = SetColorHandler;\n\n  return handlers;\n};\n\n\nModeling.prototype.updateLabel = function(element, newLabel) {\n  this._commandStack.execute('element.updateLabel', {\n    element: element,\n    newLabel: newLabel\n  });\n};\n\n\nModeling.prototype.connect = function(source, target, attrs, hints) {\n\n  var bpmnRules = this._bpmnRules;\n\n  if (!attrs) {\n    attrs = bpmnRules.canConnect(source, target) || { type: 'bpmn:Association' };\n  }\n\n  return this.createConnection(source, target, attrs, source.parent, hints);\n};\n\n\nModeling.prototype.updateProperties = function(element, properties) {\n  this._commandStack.execute('element.updateProperties', {\n    element: element,\n    properties: properties\n  });\n};\n\nModeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {\n  this._commandStack.execute('lane.resize', {\n    shape: laneShape,\n    newBounds: newBounds,\n    balanced: balanced\n  });\n};\n\nModeling.prototype.addLane = function(targetLaneShape, location) {\n  var context = {\n    shape: targetLaneShape,\n    location: location\n  };\n\n  this._commandStack.execute('lane.add', context);\n\n  return context.newLane;\n};\n\nModeling.prototype.splitLane = function(targetLane, count) {\n  this._commandStack.execute('lane.split', {\n    shape: targetLane,\n    count: count\n  });\n};\n\n/**\n * Transform the current diagram into a collaboration.\n *\n * @return {djs.model.Root} the new root element\n */\nModeling.prototype.makeCollaboration = function() {\n\n  var collaborationElement = this._create('root', {\n    type: 'bpmn:Collaboration'\n  });\n\n  var context = {\n    newRoot: collaborationElement\n  };\n\n  this._commandStack.execute('canvas.updateRoot', context);\n\n  return collaborationElement;\n};\n\nModeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {\n\n  this._commandStack.execute('lane.updateRefs', {\n    flowNodeShapes: flowNodeShapes,\n    laneShapes: laneShapes\n  });\n};\n\n/**\n * Transform the current diagram into a process.\n *\n * @return {djs.model.Root} the new root element\n */\nModeling.prototype.makeProcess = function() {\n\n  var processElement = this._create('root', {\n    type: 'bpmn:Process'\n  });\n\n  var context = {\n    newRoot: processElement\n  };\n\n  this._commandStack.execute('canvas.updateRoot', context);\n};\n\n\nModeling.prototype.claimId = function(id, moddleElement) {\n  this._commandStack.execute('id.updateClaim', {\n    id: id,\n    element: moddleElement,\n    claiming: true\n  });\n};\n\n\nModeling.prototype.unclaimId = function(id, moddleElement) {\n  this._commandStack.execute('id.updateClaim', {\n    id: id,\n    element: moddleElement\n  });\n};\n\nModeling.prototype.setColor = function(elements, colors) {\n  if (!elements.length) {\n    elements = [ elements ];\n  }\n\n  this._commandStack.execute('element.setColor', {\n    elements: elements,\n    colors: colors\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/UpdatePropertiesHandler.js":"'use strict';\n\nvar reduce = require('lodash/object/transform'),\n    keys = require('lodash/object/keys'),\n    forEach = require('lodash/collection/forEach'),\n    assign = require('lodash/object/assign');\n\nvar getBusinessObject = require('../../../util/ModelUtil').getBusinessObject;\n\nvar TextUtil = require('diagram-js/lib/util/Text');\n\nvar DEFAULT_FLOW = 'default',\n    NAME = 'name',\n    ID = 'id',\n    DI = 'di';\n\nvar NULL_DIMENSIONS = {\n  width: 0,\n  height: 0\n};\n\n/**\n * A handler that implements a BPMN 2.0 property update.\n *\n * This should be used to set simple properties on elements with\n * an underlying BPMN business object.\n *\n * Use respective diagram-js provided handlers if you would\n * like to perform automated modeling.\n */\nfunction UpdatePropertiesHandler(elementRegistry, moddle, translate, modeling) {\n  this._elementRegistry = elementRegistry;\n  this._moddle = moddle;\n  this._translate = translate;\n  this._modeling = modeling;\n\n  this._textUtil = new TextUtil();\n}\n\nUpdatePropertiesHandler.$inject = [ 'elementRegistry', 'moddle', 'translate', 'modeling' ];\n\nmodule.exports = UpdatePropertiesHandler;\n\n\n////// api /////////////////////////////////////////////\n\n/**\n * Updates a BPMN element with a list of new properties\n *\n * @param {Object} context\n * @param {djs.model.Base} context.element the element to update\n * @param {Object} context.properties a list of properties to set on the element's\n *                                    businessObject (the BPMN model element)\n *\n * @return {Array<djs.model.Base>} the updated element\n */\nUpdatePropertiesHandler.prototype.execute = function(context) {\n\n  var element = context.element,\n      changed = [ element ],\n      translate = this._translate;\n\n  if (!element) {\n    throw new Error(translate('element required'));\n  }\n\n  var elementRegistry = this._elementRegistry,\n      ids = this._moddle.ids;\n\n  var businessObject = element.businessObject,\n      properties = unwrapBusinessObjects(context.properties),\n      oldProperties = context.oldProperties || getProperties(businessObject, properties);\n\n  if (isIdChange(properties, businessObject)) {\n    ids.unclaim(businessObject[ID]);\n\n    elementRegistry.updateId(element, properties[ID]);\n\n    ids.claim(properties[ID], businessObject);\n  }\n\n  // correctly indicate visual changes on default flow updates\n  if (DEFAULT_FLOW in properties) {\n\n    if (properties[DEFAULT_FLOW]) {\n      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));\n    }\n\n    if (businessObject[DEFAULT_FLOW]) {\n      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));\n    }\n  }\n\n  if (NAME in properties && element.label) {\n    changed.push(element.label);\n\n    // show the label\n    element.label.hidden = !properties[NAME];\n  }\n\n  if (DI in properties && businessObject.di) {\n    setDiProperties(businessObject.di, properties.di);\n  }\n\n  // update properties\n  setProperties(businessObject, properties);\n\n  // store old values\n  context.oldProperties = oldProperties;\n  context.changed = changed;\n\n  // indicate changed on objects affected by the update\n  return changed;\n};\n\n\nUpdatePropertiesHandler.prototype.postExecute = function(context) {\n  var element = context.element,\n      label = element.label;\n\n  var text = label && getBusinessObject(label).name;\n\n  if (!text) {\n    return;\n  }\n\n  // get layouted text bounds and resize external\n  // external label accordingly\n  var newLabelBounds = getLayoutedBounds(label, text, this._textUtil);\n\n  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);\n};\n\n/**\n * Reverts the update on a BPMN elements properties.\n *\n * @param  {Object} context\n *\n * @return {djs.model.Base} the updated element\n */\nUpdatePropertiesHandler.prototype.revert = function(context) {\n\n  var element = context.element,\n      properties = context.properties,\n      oldProperties = context.oldProperties,\n      businessObject = element.businessObject,\n      elementRegistry = this._elementRegistry,\n      ids = this._moddle.ids;\n\n  if (DI in oldProperties && businessObject.di) {\n    setDiProperties(businessObject.di, oldProperties.di);\n  }\n\n  // update properties\n  setProperties(businessObject, oldProperties);\n\n  if (isIdChange(properties, businessObject)) {\n    ids.unclaim(properties[ID]);\n\n    elementRegistry.updateId(element, oldProperties[ID]);\n\n    ids.claim(oldProperties[ID], businessObject);\n  }\n\n  return context.changed;\n};\n\n\nfunction isIdChange(properties, businessObject) {\n  return ID in properties && properties[ID] !== businessObject[ID];\n}\n\n\nfunction getProperties(businessObject, properties) {\n  var propertyNames = keys(properties);\n\n  return reduce(propertyNames, function(result, key) {\n\n    // handle DI seperately\n    if (key !== DI) {\n      result[key] = businessObject.get(key);\n    } else {\n      result[key] = getDiProperties(businessObject.di, keys(properties.di));\n    }\n\n    return result;\n  }, {});\n}\n\n\nfunction getDiProperties(di, propertyNames) {\n  return reduce(propertyNames, function(result, key) {\n    result[key] = di.get(key);\n\n    return result;\n  }, {});\n}\n\n\nfunction setProperties(businessObject, properties) {\n  forEach(properties, function(value, key) {\n    businessObject.set(key, value);\n  });\n}\n\n\nfunction setDiProperties(di, properties) {\n  forEach(properties, function(value, key) {\n    di.set(key, value);\n  });\n}\n\n\nvar referencePropertyNames = [ 'default' ];\n\n/**\n * Make sure we unwrap the actual business object\n * behind diagram element that may have been\n * passed as arguments.\n *\n * @param  {Object} properties\n *\n * @return {Object} unwrappedProps\n */\nfunction unwrapBusinessObjects(properties) {\n\n  var unwrappedProps = assign({}, properties);\n\n  referencePropertyNames.forEach(function(name) {\n    if (name in properties) {\n      unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);\n    }\n  });\n\n  return unwrappedProps;\n}\n\n\n// TODO(nikku): repeating code (search for <getLayoutedBounds>)\n\nvar EXTERNAL_LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: '11px'\n};\n\nfunction getLayoutedBounds(bounds, text, textUtil) {\n\n  var layoutedLabelDimensions = textUtil.getDimensions(text, {\n    box: {\n      width: 90,\n      height: 30,\n      x: bounds.width / 2 + bounds.x,\n      y: bounds.height / 2 + bounds.y\n    },\n    style: EXTERNAL_LABEL_STYLE\n  });\n\n  // resize label shape to fit label text\n  return {\n    x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),\n    y: Math.round(bounds.y),\n    width: Math.ceil(layoutedLabelDimensions.width),\n    height: Math.ceil(layoutedLabelDimensions.height)\n  };\n}","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/UpdateCanvasRootHandler.js":"'use strict';\n\nvar Collections = require('diagram-js/lib/util/Collections');\n\n\nfunction UpdateCanvasRootHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\n\nUpdateCanvasRootHandler.$inject = [ 'canvas', 'modeling' ];\n\nmodule.exports = UpdateCanvasRootHandler;\n\n\nUpdateCanvasRootHandler.prototype.execute = function(context) {\n\n  var canvas = this._canvas;\n\n  var newRoot = context.newRoot,\n      newRootBusinessObject = newRoot.businessObject,\n      oldRoot = canvas.getRootElement(),\n      oldRootBusinessObject = oldRoot.businessObject,\n      bpmnDefinitions = oldRootBusinessObject.$parent,\n      diPlane = oldRootBusinessObject.di;\n\n  // (1) replace process old <> new root\n  canvas.setRootElement(newRoot, true);\n\n  // (2) update root elements\n  Collections.add(bpmnDefinitions.rootElements, newRootBusinessObject);\n  newRootBusinessObject.$parent = bpmnDefinitions;\n\n  Collections.remove(bpmnDefinitions.rootElements, oldRootBusinessObject);\n  oldRootBusinessObject.$parent = null;\n\n  // (3) wire di\n  oldRootBusinessObject.di = null;\n\n  diPlane.bpmnElement = newRootBusinessObject;\n  newRootBusinessObject.di = diPlane;\n\n  context.oldRoot = oldRoot;\n\n  // TODO(nikku): return changed elements?\n  // return [ newRoot, oldRoot ];\n};\n\n\nUpdateCanvasRootHandler.prototype.revert = function(context) {\n\n  var canvas = this._canvas;\n\n  var newRoot = context.newRoot,\n      newRootBusinessObject = newRoot.businessObject,\n      oldRoot = context.oldRoot,\n      oldRootBusinessObject = oldRoot.businessObject,\n      bpmnDefinitions = newRootBusinessObject.$parent,\n      diPlane = newRootBusinessObject.di;\n\n  // (1) replace process old <> new root\n  canvas.setRootElement(oldRoot, true);\n\n  // (2) update root elements\n  Collections.remove(bpmnDefinitions.rootElements, newRootBusinessObject);\n  newRootBusinessObject.$parent = null;\n\n  Collections.add(bpmnDefinitions.rootElements, oldRootBusinessObject);\n  oldRootBusinessObject.$parent = bpmnDefinitions;\n\n  // (3) wire di\n  newRootBusinessObject.di = null;\n\n  diPlane.bpmnElement = oldRootBusinessObject;\n  oldRootBusinessObject.di = diPlane;\n\n  // TODO(nikku): return changed elements?\n  // return [ newRoot, oldRoot ];\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/AddLaneHandler.js":"'use strict';\n\nvar filter = require('lodash/collection/filter');\n\nvar Elements = require('diagram-js/lib/util/Elements');\n\nvar getLanesRoot = require('../util/LaneUtil').getLanesRoot,\n    getChildLanes = require('../util/LaneUtil').getChildLanes,\n    LANE_INDENTATION = require('../util/LaneUtil').LANE_INDENTATION;\n\n/**\n * A handler that allows us to add a new lane\n * above or below an existing one.\n *\n * @param {Modeling} modeling\n */\nfunction AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\n\nAddLaneHandler.$inject = [ 'modeling', 'spaceTool' ];\n\nmodule.exports = AddLaneHandler;\n\n\nAddLaneHandler.prototype.preExecute = function(context) {\n\n  var spaceTool = this._spaceTool,\n      modeling = this._modeling;\n\n  var shape = context.shape,\n      location = context.location;\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var isRoot = lanesRoot === shape,\n      laneParent = isRoot ? shape : shape.parent;\n\n  var existingChildLanes = getChildLanes(laneParent);\n\n  // (0) add a lane if we currently got none and are adding to root\n  if (!existingChildLanes.length) {\n    modeling.createShape({ type: 'bpmn:Lane' }, {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    }, laneParent);\n  }\n\n  // (1) collect affected elements to create necessary space\n  var allAffected = [];\n\n  Elements.eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    if (element === shape) {\n      return [];\n    }\n\n    return filter(element.children, function(c) {\n      return c !== shape;\n    });\n  });\n\n  var offset = location === 'top' ? -120 : 120,\n      lanePosition = location === 'top' ? shape.y : shape.y + shape.height,\n      spacePos = lanePosition + (location === 'top' ? 10 : -10),\n      direction = location === 'top' ? 'n' : 's';\n\n  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset }, direction);\n\n  // (2) create new lane at open space\n  context.newLane = modeling.createShape({ type: 'bpmn:Lane' }, {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  }, laneParent);\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js":"'use strict';\n\nvar getChildLanes = require('../util/LaneUtil').getChildLanes;\n\nvar LANE_INDENTATION = require('../util/LaneUtil').LANE_INDENTATION;\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if neccessary.\n *\n * @param {Modeling} modeling\n */\nfunction SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}\n\nSplitLaneHandler.$inject = [ 'modeling', 'translate'];\n\nmodule.exports = SplitLaneHandler;\n\n\nSplitLaneHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling,\n      translate = this._translate;\n\n  var shape = context.shape,\n      newLanesCount = context.count;\n\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));\n  }\n\n  var newLanesHeight = Math.round(shape.height / newLanesCount);\n\n  // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n  var laneY,\n      laneHeight,\n      laneBounds,\n      newLaneAttrs,\n      idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n\n    laneY = shape.y + idx * newLanesHeight;\n\n    // if bottom lane\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - (newLanesHeight * idx);\n    } else {\n      laneHeight = newLanesHeight;\n    }\n\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/ResizeLaneHandler.js":"'use strict';\n\nvar is = require('../../../util/ModelUtil').is;\n\nvar getLanesRoot = require('../util/LaneUtil').getLanesRoot,\n    computeLanesResize = require('../util/LaneUtil').computeLanesResize;\n\nvar eachElement = require('diagram-js/lib/util/Elements').eachElement;\n\nvar asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL,\n    substractTRBL = require('diagram-js/lib/features/resize/ResizeUtil').substractTRBL;\n\n\n/**\n * A handler that resizes a lane.\n *\n * @param {Modeling} modeling\n */\nfunction ResizeLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\n\nResizeLaneHandler.$inject = [ 'modeling', 'spaceTool' ];\n\nmodule.exports = ResizeLaneHandler;\n\n\nResizeLaneHandler.prototype.preExecute = function(context) {\n\n  var shape = context.shape,\n      newBounds = context.newBounds,\n      balanced = context.balanced;\n\n  if (balanced !== false) {\n    this.resizeBalanced(shape, newBounds);\n  } else {\n    this.resizeSpace(shape, newBounds);\n  }\n};\n\n\n/**\n * Resize balanced, adjusting next / previous lane sizes.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n */\nResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {\n\n  var modeling = this._modeling;\n\n  var resizeNeeded = computeLanesResize(shape, newBounds);\n\n  // resize the lane\n  modeling.resizeShape(shape, newBounds);\n\n  // resize other lanes as needed\n  resizeNeeded.forEach(function(r) {\n    modeling.resizeShape(r.shape, r.newBounds);\n  });\n};\n\n\n/**\n * Resize, making actual space and moving below / above elements.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n */\nResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {\n  var spaceTool = this._spaceTool;\n\n  var shapeTrbl = asTRBL(shape),\n      newTrbl = asTRBL(newBounds);\n\n  var trblDiff = substractTRBL(newTrbl, shapeTrbl);\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var allAffected = [],\n      allLanes = [];\n\n  eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    if (is(element, 'bpmn:Lane') || is(element, 'bpmn:Participant')) {\n      allLanes.push(element);\n    }\n\n    return element.children;\n  });\n\n  var change,\n      spacePos,\n      direction,\n      offset,\n      adjustments;\n\n  if (trblDiff.bottom || trblDiff.top) {\n\n    change = trblDiff.bottom || trblDiff.top;\n    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);\n    direction = trblDiff.bottom ? 's' : 'n';\n\n    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;\n\n    adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);\n  }\n\n\n  if (trblDiff.left || trblDiff.right) {\n\n    change = trblDiff.right || trblDiff.left;\n    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);\n    direction = trblDiff.right ? 'e' : 'w';\n\n    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;\n\n    adjustments = spaceTool.calculateAdjustments(allLanes, 'x', offset, spacePos);\n\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);\n  }\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js":"'use strict';\n\nvar collectLanes = require('../util/LaneUtil').collectLanes;\n\nvar getLanesRoot = require('../util/LaneUtil').getLanesRoot;\n\nvar is = require('../../../util/ModelUtil').is;\n\nvar Collections = require('diagram-js/lib/util/Collections');\n\nvar asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL;\n\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\n    LANES_ATTR = 'lanes';\n\n/**\n * A handler that updates lane refs on changed elements\n */\nfunction UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\n\nUpdateFlowNodeRefsHandler.$inject = [ 'elementRegistry' ];\n\nmodule.exports = UpdateFlowNodeRefsHandler;\n\n\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {\n\n  var handledNodes = {};\n\n  var updates = [];\n\n  var participantCache = {};\n\n  var allFlowNodeShapes = [];\n\n  function isInLaneShape(element, laneShape) {\n\n    var laneTrbl = asTRBL(laneShape);\n\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n\n    return elementMid.x > laneTrbl.left &&\n           elementMid.x < laneTrbl.right &&\n           elementMid.y > laneTrbl.top &&\n           elementMid.y < laneTrbl.bottom;\n  }\n\n  function addFlowNodeShape(flowNodeShape) {\n    if (!handledNodes[flowNodeShape.id]) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes[flowNodeShape.id] = flowNodeShape;\n    }\n  }\n\n  function getAllLaneShapes(flowNodeShape) {\n\n    var root = getLanesRoot(flowNodeShape);\n\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n\n    return participantCache[root.id];\n  }\n\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n\n    return allLaneShapes.filter(function(l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function(shape) {\n      return shape.businessObject;\n    });\n  }\n\n  laneShapes.forEach(function(laneShape) {\n    var root = getLanesRoot(laneShape);\n\n    if (!root || handledNodes[root.id]) {\n      return;\n    }\n\n    var children = root.children.filter(function(c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n\n    children.forEach(addFlowNodeShape);\n\n    handledNodes[root.id] = root;\n  });\n\n  flowNodeShapes.forEach(addFlowNodeShape);\n\n\n  allFlowNodeShapes.forEach(function(flowNodeShape) {\n\n    var flowNode = flowNodeShape.businessObject;\n\n    var lanes = flowNode.get(LANES_ATTR),\n        remove = lanes.slice(),\n        add = getNewLanes(flowNodeShape);\n\n    updates.push({ flowNode: flowNode, remove: remove, add: add });\n  });\n\n  laneShapes.forEach(function(laneShape) {\n\n    var lane = laneShape.businessObject;\n\n    // lane got removed XX-)\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {\n        updates.push({ flowNode: flowNode, remove: [ lane ], add: [] });\n      });\n    }\n  });\n\n  return updates;\n};\n\nUpdateFlowNodeRefsHandler.prototype.execute = function(context) {\n\n  var updates = context.updates;\n\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire old\n    update.remove.forEach(function(oldLane) {\n      Collections.remove(lanes, oldLane);\n      Collections.remove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire new\n    update.add.forEach(function(newLane) {\n      Collections.add(lanes, newLane);\n      Collections.add(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n\n\nUpdateFlowNodeRefsHandler.prototype.revert = function(context) {\n\n  var updates = context.updates;\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire new\n    update.add.forEach(function(newLane) {\n      Collections.remove(lanes, newLane);\n      Collections.remove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire old\n    update.remove.forEach(function(oldLane) {\n      Collections.add(lanes, oldLane);\n      Collections.add(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/IdClaimHandler.js":"'use strict';\n\n\nfunction IdClaimHandler(moddle) {\n  this._moddle = moddle;\n}\n\nIdClaimHandler.$inject = [ 'moddle' ];\n\nmodule.exports = IdClaimHandler;\n\n\nIdClaimHandler.prototype.execute = function(context) {\n  var ids = this._moddle.ids,\n      id = context.id,\n      element = context.element,\n      claiming = context.claiming;\n\n  if (claiming) {\n    ids.claim(id, element);\n  } else {\n    ids.unclaim(id);\n  }\n};\n\n/**\n * Command revert implementation.\n */\nIdClaimHandler.prototype.revert = function(context) {\n  var ids = this._moddle.ids,\n      id = context.id,\n      element = context.element,\n      claiming = context.claiming;\n\n  if (claiming) {\n    ids.unclaim(id);\n  } else {\n    ids.claim(id, element);\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/modeling/cmd/SetColorHandler.js":"'use strict';\r\n\r\nvar assign = require('lodash/object/assign'),\r\n    forEach = require('lodash/collection/forEach');\r\n\r\nfunction SetColorHandler(commandStack) {\r\n  this._commandStack = commandStack;\r\n}\r\n\r\nSetColorHandler.$inject = [ 'commandStack' ];\r\n\r\nmodule.exports = SetColorHandler;\r\n\r\nSetColorHandler.prototype.postExecute = function(context) {\r\n  var elements = context.elements,\r\n      colors = context.colors || { fill: undefined, stroke: undefined };\r\n\r\n  var that = this;\r\n\r\n  var di = {};\r\n\r\n  if ('fill' in colors) {\r\n    assign(di, { fill: colors.fill });\r\n  }\r\n\r\n  if ('stroke' in colors) {\r\n    assign(di, { stroke: colors.stroke });\r\n  }\r\n\r\n  forEach(elements, function(element) {\r\n    that._commandStack.execute('element.updateProperties', {\r\n      element: element,\r\n      properties: {\r\n        di: di\r\n      }\r\n    });\r\n  });\r\n\r\n};\r\n\r\nSetColorHandler.prototype.execute = function(context) {};\r\n\r\nSetColorHandler.prototype.revert = function(context) {};\r\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/ordering/BpmnOrderingProvider.js":"'use strict';\n\nvar inherits = require('inherits');\n\nvar OrderingProvider = require('diagram-js/lib/features/ordering/OrderingProvider');\n\nvar isAny = require('../modeling/util/ModelingUtil').isAny;\n\nvar findIndex = require('lodash/array/findIndex');\n\nvar find = require('lodash/collection/find');\n\n\n/**\n * a simple ordering provider that makes sure:\n *\n * (1) elements are ordered by a {level} property\n * (2) elements with {alwaysOnTop} are always added to the root\n */\nfunction BpmnOrderingProvider(eventBus, translate) {\n\n  OrderingProvider.call(this, eventBus);\n\n  var orders = [\n    { type: 'bpmn:SubProcess', order: { level: 6 } },\n    {\n      type: 'bpmn:SequenceFlow',\n      order: {\n        level: 5,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer'\n        ]\n      }\n    },\n    // handle DataAssociation(s) like message flows and render them always on top\n    { type: 'bpmn:DataAssociation', order: { level: 9, containers: [ 'bpmn:Collaboration', 'bpmn:Process' ] } },\n    { type: 'bpmn:MessageFlow', order: { level: 9, containers: [ 'bpmn:Collaboration' ] } },\n    {\n      type: 'bpmn:Association',\n      order: {\n        level: 6,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer',\n          'bpmn:Collaboration'\n        ]\n      }\n    },\n    { type: 'bpmn:BoundaryEvent', order: { level: 8 } },\n    { type: 'bpmn:Participant', order: { level: -2 } },\n    { type: 'bpmn:Lane', order: { level: -1 } }\n  ];\n\n  function computeOrder(element) {\n    if (element.labelTarget) {\n      return { level: 10 };\n    }\n\n    var entry = find(orders, function(o) {\n      return isAny(element, [ o.type ]);\n    });\n\n    return entry && entry.order || { level: 1 };\n  }\n\n  function getOrder(element) {\n\n    var order = element.order;\n\n    if (!order) {\n      element.order = order = computeOrder(element);\n    }\n\n    return order;\n  }\n\n  function findActualParent(element, newParent, containers) {\n\n    var actualParent = newParent;\n\n    while (actualParent) {\n\n      if (isAny(actualParent, containers)) {\n        break;\n      }\n\n      actualParent = actualParent.parent;\n    }\n\n    if (!actualParent) {\n      throw new Error(translate('no parent for {element} in {parent}', {\n        element: element.id,\n        parent: newParent.id\n      }));\n    }\n\n    return actualParent;\n  }\n\n  this.getOrdering = function(element, newParent) {\n\n    var elementOrder = getOrder(element);\n\n\n    if (elementOrder.containers) {\n      newParent = findActualParent(element, newParent, elementOrder.containers);\n    }\n\n\n    var currentIndex = newParent.children.indexOf(element);\n\n    var insertIndex = findIndex(newParent.children, function(child) {\n\n      // do not compare with labels, they are created\n      // in the wrong order (right after elements) during import and\n      // mess up the positioning.\n      if (!element.labelTarget && child.labelTarget) {\n        return false;\n      }\n\n      return elementOrder.level < getOrder(child).level;\n    });\n\n\n    // if the element is already in the child list at\n    // a smaller index, we need to adjust the inser index.\n    // this takes into account that the element is being removed\n    // before being re-inserted\n    if (insertIndex !== -1) {\n      if (currentIndex !== -1 && currentIndex < insertIndex) {\n        insertIndex -= 1;\n      }\n    }\n\n    return {\n      index: insertIndex,\n      parent: newParent\n    };\n  };\n}\n\nBpmnOrderingProvider.$inject = [ 'eventBus', 'translate' ];\n\ninherits(BpmnOrderingProvider, OrderingProvider);\n\nmodule.exports = BpmnOrderingProvider;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/palette/PaletteProvider.js":"'use strict';\n\nvar assign = require('lodash/object/assign');\n\n/**\n * A palette provider for BPMN 2.0 elements.\n */\nfunction PaletteProvider(palette, create, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate) {\n\n  this._palette = palette;\n  this._create = create;\n  this._elementFactory = elementFactory;\n  this._spaceTool = spaceTool;\n  this._lassoTool = lassoTool;\n  this._handTool = handTool;\n  this._globalConnect = globalConnect;\n  this._translate = translate;\n\n  palette.registerProvider(this);\n}\n\nmodule.exports = PaletteProvider;\n\nPaletteProvider.$inject = [\n  'palette',\n  'create',\n  'elementFactory',\n  'spaceTool',\n  'lassoTool',\n  'handTool',\n  'globalConnect',\n  'translate'\n];\n\n\nPaletteProvider.prototype.getPaletteEntries = function(element) {\n\n  var actions  = {},\n      create = this._create,\n      elementFactory = this._elementFactory,\n      spaceTool = this._spaceTool,\n      lassoTool = this._lassoTool,\n      handTool = this._handTool,\n      globalConnect = this._globalConnect,\n      translate = this._translate;\n\n  function createAction(type, group, className, title, options) {\n\n    function createListener(event) {\n      var shape = elementFactory.createShape(assign({ type: type }, options));\n\n      if (options) {\n        shape.businessObject.di.isExpanded = options.isExpanded;\n      }\n\n      create.start(event, shape);\n    }\n\n    var shortType = type.replace(/^bpmn\\:/, '');\n\n    return {\n      group: group,\n      className: className,\n      title: title || translate('Create {type}', { type: shortType }),\n      action: {\n        dragstart: createListener,\n        click: createListener\n      }\n    };\n  }\n\n  function createParticipant(event, collapsed) {\n    create.start(event, elementFactory.createParticipantShape(collapsed));\n  }\n\n  assign(actions, {\n    'hand-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-hand-tool',\n      title: translate('Activate the hand tool'),\n      action: {\n        click: function(event) {\n          handTool.activateHand(event);\n        }\n      }\n    },\n    'lasso-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-lasso-tool',\n      title: translate('Activate the lasso tool'),\n      action: {\n        click: function(event) {\n          lassoTool.activateSelection(event);\n        }\n      }\n    },\n    'space-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-space-tool',\n      title: translate('Activate the create/remove space tool'),\n      action: {\n        click: function(event) {\n          spaceTool.activateSelection(event);\n        }\n      }\n    },\n    'global-connect-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-connection-multi',\n      title: translate('Activate the global connect tool'),\n      action: {\n        click: function(event) {\n          globalConnect.toggle(event);\n        }\n      }\n    },\n    'tool-separator': {\n      group: 'tools',\n      separator: true\n    },\n    'create.start-event': createAction(\n      'bpmn:StartEvent', 'event', 'bpmn-icon-start-event-none'\n    ),\n    'create.intermediate-event': createAction('bpmn:IntermediateThrowEvent', 'event',\n      'bpmn-icon-intermediate-event-none', translate('Create IntermediateThrowEvent/BoundaryEvent')\n    ),\n    'create.end-event': createAction(\n      'bpmn:EndEvent', 'event', 'bpmn-icon-end-event-none'\n    ),\n    'create.exclusive-gateway': createAction(\n      'bpmn:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-xor'\n    ),\n    'create.task': createAction(\n      'bpmn:Task', 'activity', 'bpmn-icon-task'\n    ),\n    'create.data-object': createAction(\n      'bpmn:DataObjectReference', 'data-object', 'bpmn-icon-data-object'\n    ),\n    'create.data-store': createAction(\n      'bpmn:DataStoreReference', 'data-store', 'bpmn-icon-data-store'\n    ),\n    'create.subprocess-expanded': createAction(\n      'bpmn:SubProcess', 'activity', 'bpmn-icon-subprocess-expanded', translate('Create expanded SubProcess'),\n      { isExpanded: true }\n    ),\n    'create.participant-expanded': {\n      group: 'collaboration',\n      className: 'bpmn-icon-participant',\n      title: translate('Create Pool/Participant'),\n      action: {\n        dragstart: createParticipant,\n        click: createParticipant\n      }\n    }\n  });\n\n  return actions;\n};\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/popup-menu/ReplaceMenuProvider.js":"'use strict';\n\nvar is = require('../../util/ModelUtil').is,\n    isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,\n    getBusinessObject = require('../../util/ModelUtil').getBusinessObject,\n    isExpanded = require('../../util/DiUtil').isExpanded,\n    isDifferentType = require('./util/TypeUtil').isDifferentType;\n\nvar forEach = require('lodash/collection/forEach'),\n    filter = require('lodash/collection/filter'),\n    reject = require('lodash/collection/reject');\n\nvar replaceOptions = require ('../replace/ReplaceOptions');\n\n\n/**\n * This module is an element agnostic replace menu provider for the popup menu.\n */\nfunction ReplaceMenuProvider(popupMenu, modeling, moddle, bpmnReplace, rules, translate) {\n\n  this._popupMenu = popupMenu;\n  this._modeling = modeling;\n  this._moddle = moddle;\n  this._bpmnReplace = bpmnReplace;\n  this._rules = rules;\n  this._translate = translate;\n\n  this.register();\n}\n\nReplaceMenuProvider.$inject = [ 'popupMenu', 'modeling', 'moddle', 'bpmnReplace', 'rules', 'translate' ];\n\n\n/**\n * Register replace menu provider in the popup menu\n */\nReplaceMenuProvider.prototype.register = function() {\n  this._popupMenu.registerProvider('bpmn-replace', this);\n};\n\n\n/**\n * Get all entries from replaceOptions for the given element and apply filters\n * on them. Get for example only elements, which are different from the current one.\n *\n * @param {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu entry items\n */\nReplaceMenuProvider.prototype.getEntries = function(element) {\n\n  var businessObject = element.businessObject;\n\n  var rules = this._rules;\n\n  var entries;\n\n  if (!rules.allowed('shape.replace', { element: element })) {\n    return [];\n  }\n\n  var differentType = isDifferentType(element);\n\n  // start events outside event sub processes\n  if (is(businessObject, 'bpmn:StartEvent') && !isEventSubProcess(businessObject.$parent)) {\n\n    entries = filter(replaceOptions.START_EVENT, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded/collapsed pools\n  if (is(businessObject, 'bpmn:Participant')) {\n\n    entries = filter(replaceOptions.PARTICIPANT, function(entry) {\n      return isExpanded(businessObject) !== entry.target.isExpanded;\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // start events inside event sub processes\n  if (is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent)) {\n\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS_START_EVENT, function(entry) {\n\n      var target = entry.target;\n\n      var isInterrupting = target.isInterrupting !== false;\n\n      var isInterruptingEqual = getBusinessObject(element).isInterrupting === isInterrupting;\n\n      // filters elements which types and event definition are equal but have have different interrupting types\n      return differentType(entry) || !differentType(entry) && !isInterruptingEqual;\n\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // end events\n  if (is(businessObject, 'bpmn:EndEvent')) {\n\n    entries = filter(replaceOptions.END_EVENT, function(entry) {\n      var target = entry.target;\n\n      // hide cancel end events outside transactions\n      if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !is(businessObject.$parent, 'bpmn:Transaction')) {\n        return false;\n      }\n\n      return differentType(entry);\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // boundary events\n  if (is(businessObject, 'bpmn:BoundaryEvent')) {\n\n    entries = filter(replaceOptions.BOUNDARY_EVENT, function(entry) {\n\n      var target = entry.target;\n\n      if (target.eventDefinition == 'bpmn:CancelEventDefinition' &&\n         !is(businessObject.attachedToRef, 'bpmn:Transaction')) {\n        return false;\n      }\n      var cancelActivity = target.cancelActivity !== false;\n\n      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;\n\n      return differentType(entry) || !differentType(entry) && !isCancelActivityEqual;\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // intermediate events\n  if (is(businessObject, 'bpmn:IntermediateCatchEvent') ||\n      is(businessObject, 'bpmn:IntermediateThrowEvent')) {\n\n    entries = filter(replaceOptions.INTERMEDIATE_EVENT, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // gateways\n  if (is(businessObject, 'bpmn:Gateway')) {\n\n    entries = filter(replaceOptions.GATEWAY, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // transactions\n  if (is(businessObject, 'bpmn:Transaction')) {\n\n    entries = filter(replaceOptions.TRANSACTION, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded event sub processes\n  if (isEventSubProcess(businessObject) && isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded sub processes\n  if (is(businessObject, 'bpmn:SubProcess') && isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.SUBPROCESS_EXPANDED, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // collapsed ad hoc sub processes\n  if (is(businessObject, 'bpmn:AdHocSubProcess') && !isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.TASK, function(entry) {\n\n      var target = entry.target;\n\n      var isTargetSubProcess = target.type === 'bpmn:SubProcess';\n\n      var isTargetExpanded = target.isExpanded === true;\n\n      return isDifferentType(element, target) && ( !isTargetSubProcess || isTargetExpanded );\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // sequence flows\n  if (is(businessObject, 'bpmn:SequenceFlow')) {\n    return this._createSequenceFlowEntries(element, replaceOptions.SEQUENCE_FLOW);\n  }\n\n  // flow nodes\n  if (is(businessObject, 'bpmn:FlowNode')) {\n    entries = filter(replaceOptions.TASK, differentType);\n\n    // collapsed SubProcess can not be replaced with itself\n    if (is(businessObject, 'bpmn:SubProcess') && !isExpanded(businessObject)) {\n      entries = reject(entries, function(entry) {\n        return entry.label === 'Sub Process (collapsed)';\n      });\n    }\n\n    return this._createEntries(element, entries);\n  }\n\n  return [];\n};\n\n\n/**\n * Get a list of header items for the given element. This includes buttons\n * for multi instance markers and for the ad hoc marker.\n *\n * @param {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu entry items\n */\nReplaceMenuProvider.prototype.getHeaderEntries = function(element) {\n\n  var headerEntries = [];\n\n  if (is(element, 'bpmn:Activity') && !isEventSubProcess(element)) {\n    headerEntries = headerEntries.concat(this._getLoopEntries(element));\n  }\n\n  if (is(element, 'bpmn:SubProcess') &&\n      !is(element, 'bpmn:Transaction') &&\n      !isEventSubProcess(element)) {\n    headerEntries.push(this._getAdHocEntry(element));\n  }\n\n  return headerEntries;\n};\n\n\n/**\n * Creates an array of menu entry objects for a given element and filters the replaceOptions\n * according to a filter function.\n *\n * @param  {djs.model.Base} element\n * @param  {Object} replaceOptions\n *\n * @return {Array<Object>} a list of menu items\n */\nReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {\n  var menuEntries = [];\n\n  var self = this;\n\n  forEach(replaceOptions, function(definition) {\n    var entry = self._createMenuEntry(definition, element);\n\n    menuEntries.push(entry);\n  });\n\n  return menuEntries;\n};\n\n/**\n * Creates an array of menu entry objects for a given sequence flow.\n *\n * @param  {djs.model.Base} element\n * @param  {Object} replaceOptions\n\n * @return {Array<Object>} a list of menu items\n */\nReplaceMenuProvider.prototype._createSequenceFlowEntries = function(element, replaceOptions) {\n\n  var businessObject = getBusinessObject(element);\n\n  var menuEntries = [];\n\n  var modeling = this._modeling,\n      moddle = this._moddle;\n\n  var self = this;\n\n  forEach(replaceOptions, function(entry) {\n\n    switch (entry.actionName) {\n    case 'replace-with-default-flow':\n      if (businessObject.sourceRef.default !== businessObject &&\n            (is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||\n             is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||\n             is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||\n             is(businessObject.sourceRef, 'bpmn:Activity'))) {\n\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element.source, { default: businessObject });\n        }));\n      }\n      break;\n    case 'replace-with-conditional-flow':\n      if (!businessObject.conditionExpression && is(businessObject.sourceRef, 'bpmn:Activity')) {\n\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\n          var conditionExpression = moddle.create('bpmn:FormalExpression', { body: '' });\n\n          modeling.updateProperties(element, { conditionExpression: conditionExpression });\n        }));\n      }\n      break;\n    default:\n        // default flows\n      if (is(businessObject.sourceRef, 'bpmn:Activity') && businessObject.conditionExpression) {\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element, { conditionExpression: undefined });\n        }));\n      }\n        // conditional flows\n      if ((is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||\n           is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||\n           is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||\n           is(businessObject.sourceRef, 'bpmn:Activity')) &&\n           businessObject.sourceRef.default === businessObject) {\n\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element.source, { default: undefined });\n        }));\n      }\n    }\n  });\n\n  return menuEntries;\n};\n\n\n/**\n * Creates and returns a single menu entry item.\n *\n * @param  {Object} definition a single replace options definition object\n * @param  {djs.model.Base} element\n * @param  {Function} [action] an action callback function which gets called when\n *                             the menu entry is being triggered.\n *\n * @return {Object} menu entry item\n */\nReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {\n  var translate = this._translate;\n  var replaceElement = this._bpmnReplace.replaceElement;\n\n  var replaceAction = function() {\n    return replaceElement(element, definition.target);\n  };\n\n  action = action || replaceAction;\n\n  var menuEntry = {\n    label: translate(definition.label),\n    className: definition.className,\n    id: definition.actionName,\n    action: action\n  };\n\n  return menuEntry;\n};\n\n/**\n * Get a list of menu items containing buttons for multi instance markers\n *\n * @param  {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu items\n */\nReplaceMenuProvider.prototype._getLoopEntries = function(element) {\n\n  var self = this;\n  var translate = this._translate;\n\n  function toggleLoopEntry(event, entry) {\n    var loopCharacteristics;\n\n    if (entry.active) {\n      loopCharacteristics = undefined;\n    } else {\n      loopCharacteristics = self._moddle.create(entry.options.loopCharacteristics);\n\n      if (entry.options.isSequential) {\n        loopCharacteristics.isSequential = entry.options.isSequential;\n      }\n    }\n    self._modeling.updateProperties(element, { loopCharacteristics: loopCharacteristics });\n  }\n\n  var businessObject = getBusinessObject(element),\n      loopCharacteristics = businessObject.loopCharacteristics;\n\n  var isSequential,\n      isLoop,\n      isParallel;\n\n  if (loopCharacteristics) {\n    isSequential = loopCharacteristics.isSequential;\n    isLoop = loopCharacteristics.isSequential === undefined;\n    isParallel = loopCharacteristics.isSequential !== undefined && !loopCharacteristics.isSequential;\n  }\n\n\n  var loopEntries = [\n    {\n      id: 'toggle-parallel-mi',\n      className: 'bpmn-icon-parallel-mi-marker',\n      title: translate('Parallel Multi Instance'),\n      active: isParallel,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',\n        isSequential: false\n      }\n    },\n    {\n      id: 'toggle-sequential-mi',\n      className: 'bpmn-icon-sequential-mi-marker',\n      title: translate('Sequential Multi Instance'),\n      active: isSequential,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',\n        isSequential: true\n      }\n    },\n    {\n      id: 'toggle-loop',\n      className: 'bpmn-icon-loop-marker',\n      title: translate('Loop'),\n      active: isLoop,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:StandardLoopCharacteristics'\n      }\n    }\n  ];\n  return loopEntries;\n};\n\n\n/**\n * Get the menu items containing a button for the ad hoc marker\n *\n * @param  {djs.model.Base} element\n *\n * @return {Object} a menu item\n */\nReplaceMenuProvider.prototype._getAdHocEntry = function(element) {\n  var translate = this._translate;\n  var businessObject = getBusinessObject(element);\n\n  var isAdHoc = is(businessObject, 'bpmn:AdHocSubProcess');\n\n  var replaceElement = this._bpmnReplace.replaceElement;\n\n  var adHocEntry = {\n    id: 'toggle-adhoc',\n    className: 'bpmn-icon-ad-hoc-marker',\n    title: translate('Ad-hoc'),\n    active: isAdHoc,\n    action: function(event, entry) {\n      if (isAdHoc) {\n        return replaceElement(element, { type: 'bpmn:SubProcess' });\n      } else {\n        return replaceElement(element, { type: 'bpmn:AdHocSubProcess' });\n      }\n    }\n  };\n\n  return adHocEntry;\n};\n\nmodule.exports = ReplaceMenuProvider;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/popup-menu/util/TypeUtil.js":"'use strict';\n\nvar getBusinessObject = require('../../../util/ModelUtil').getBusinessObject;\nvar isExpanded = require('../../../util/DiUtil').isExpanded;\n\n/**\n * Returns true, if an element is from a different type\n * than a target definition. Takes into account the type,\n * event definition type and triggeredByEvent property.\n *\n * @param {djs.model.Base} element\n *\n * @return {Boolean}\n */\nfunction isDifferentType(element) {\n\n  return function(entry) {\n    var target = entry.target;\n\n    var businessObject = getBusinessObject(element),\n        eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];\n\n    var isTypeEqual = businessObject.$type === target.type;\n\n    var isEventDefinitionEqual = (\n      (eventDefinition && eventDefinition.$type) === target.eventDefinitionType\n    );\n\n    var isTriggeredByEventEqual = (\n      businessObject.triggeredByEvent === target.triggeredByEvent\n    );\n\n    var isExpandedEqual = (\n        target.isExpanded === undefined ||\n        target.isExpanded === isExpanded(businessObject)\n    );\n\n    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;\n  };\n}\n\nmodule.exports.isDifferentType = isDifferentType;","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/replace/ReplaceOptions.js":"'use strict';\n\nmodule.exports.START_EVENT = [\n  {\n    label: 'Start Event',\n    actionName: 'replace-with-none-start',\n    className: 'bpmn-icon-start-event-none',\n    target: {\n      type: 'bpmn:StartEvent'\n    }\n  },\n  {\n    label: 'Intermediate Throw Event',\n    actionName: 'replace-with-none-intermediate-throwing',\n    className: 'bpmn-icon-intermediate-event-none',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent'\n    }\n  },\n  {\n    label: 'End Event',\n    actionName: 'replace-with-none-end',\n    className: 'bpmn-icon-end-event-none',\n    target: {\n      type: 'bpmn:EndEvent'\n    }\n  },\n  {\n    label: 'Message Start Event',\n    actionName: 'replace-with-message-start',\n    className: 'bpmn-icon-start-event-message',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Start Event',\n    actionName: 'replace-with-timer-start',\n    className: 'bpmn-icon-start-event-timer',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Start Event',\n    actionName: 'replace-with-conditional-start',\n    className: 'bpmn-icon-start-event-condition',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Start Event',\n    actionName: 'replace-with-signal-start',\n    className: 'bpmn-icon-start-event-signal',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  }\n];\n\nmodule.exports.INTERMEDIATE_EVENT = [\n  {\n    label: 'Start Event',\n    actionName: 'replace-with-none-start',\n    className: 'bpmn-icon-start-event-none',\n    target: {\n      type: 'bpmn:StartEvent'\n    }\n  },\n  {\n    label: 'Intermediate Throw Event',\n    actionName: 'replace-with-none-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-none',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent'\n    }\n  },\n  {\n    label: 'End Event',\n    actionName: 'replace-with-none-end',\n    className: 'bpmn-icon-end-event-none',\n    target: {\n      type: 'bpmn:EndEvent'\n    }\n  },\n  {\n    label: 'Message Intermediate Catch Event',\n    actionName: 'replace-with-message-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-message',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Message Intermediate Throw Event',\n    actionName: 'replace-with-message-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-message',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Intermediate Catch Event',\n    actionName: 'replace-with-timer-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-timer',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation Intermediate Throw Event',\n    actionName: 'replace-with-escalation-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-escalation',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Intermediate Catch Event',\n    actionName: 'replace-with-conditional-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-condition',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Link Intermediate Catch Event',\n    actionName: 'replace-with-link-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-link',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:LinkEventDefinition'\n    }\n  },\n  {\n    label: 'Link Intermediate Throw Event',\n    actionName: 'replace-with-link-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-link',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:LinkEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation Intermediate Throw Event',\n    actionName: 'replace-with-compensation-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-compensation',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Intermediate Catch Event',\n    actionName: 'replace-with-signal-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-signal',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Intermediate Throw Event',\n    actionName: 'replace-with-signal-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-signal',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  }\n];\n\nmodule.exports.END_EVENT = [\n  {\n    label: 'Start Event',\n    actionName: 'replace-with-none-start',\n    className: 'bpmn-icon-start-event-none',\n    target: {\n      type: 'bpmn:StartEvent'\n    }\n  },\n  {\n    label: 'Intermediate Throw Event',\n    actionName: 'replace-with-none-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-none',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent'\n    }\n  },\n  {\n    label: 'End Event',\n    actionName: 'replace-with-none-end',\n    className: 'bpmn-icon-end-event-none',\n    target: {\n      type: 'bpmn:EndEvent'\n    }\n  },\n  {\n    label: 'Message End Event',\n    actionName: 'replace-with-message-end',\n    className: 'bpmn-icon-end-event-message',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation End Event',\n    actionName: 'replace-with-escalation-end',\n    className: 'bpmn-icon-end-event-escalation',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Error End Event',\n    actionName: 'replace-with-error-end',\n    className: 'bpmn-icon-end-event-error',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:ErrorEventDefinition'\n    }\n  },\n  {\n    label: 'Cancel End Event',\n    actionName: 'replace-with-cancel-end',\n    className: 'bpmn-icon-end-event-cancel',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:CancelEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation End Event',\n    actionName: 'replace-with-compensation-end',\n    className: 'bpmn-icon-end-event-compensation',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Signal End Event',\n    actionName: 'replace-with-signal-end',\n    className: 'bpmn-icon-end-event-signal',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Terminate End Event',\n    actionName: 'replace-with-terminate-end',\n    className: 'bpmn-icon-end-event-terminate',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:TerminateEventDefinition'\n    }\n  }\n];\n\nmodule.exports.GATEWAY = [\n  {\n    label: 'Exclusive Gateway',\n    actionName: 'replace-with-exclusive-gateway',\n    className: 'bpmn-icon-gateway-xor',\n    target: {\n      type: 'bpmn:ExclusiveGateway'\n    }\n  },\n  {\n    label: 'Parallel Gateway',\n    actionName: 'replace-with-parallel-gateway',\n    className: 'bpmn-icon-gateway-parallel',\n    target: {\n      type: 'bpmn:ParallelGateway'\n    }\n  },\n  {\n    label: 'Inclusive Gateway',\n    actionName: 'replace-with-inclusive-gateway',\n    className: 'bpmn-icon-gateway-or',\n    target: {\n      type: 'bpmn:InclusiveGateway'\n    }\n  },\n  {\n    label: 'Complex Gateway',\n    actionName: 'replace-with-complex-gateway',\n    className: 'bpmn-icon-gateway-complex',\n    target: {\n      type: 'bpmn:ComplexGateway'\n    }\n  },\n  {\n    label: 'Event based Gateway',\n    actionName: 'replace-with-event-based-gateway',\n    className: 'bpmn-icon-gateway-eventbased',\n    target: {\n      type: 'bpmn:EventBasedGateway',\n      instantiate: false,\n      eventGatewayType: 'Exclusive'\n    }\n  }\n  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194\n  // {\n  //   label: 'Event based instantiating Gateway',\n  //   actionName: 'replace-with-exclusive-event-based-gateway',\n  //   className: 'bpmn-icon-exclusive-event-based',\n  //   target: {\n  //     type: 'bpmn:EventBasedGateway'\n  //   },\n  //   options: {\n  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }\n  //   }\n  // },\n  // {\n  //   label: 'Parallel Event based instantiating Gateway',\n  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',\n  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',\n  //   target: {\n  //     type: 'bpmn:EventBasedGateway'\n  //   },\n  //   options: {\n  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }\n  //   }\n  // }\n];\n\nmodule.exports.SUBPROCESS_EXPANDED = [\n  {\n    label: 'Transaction',\n    actionName: 'replace-with-transaction',\n    className: 'bpmn-icon-transaction',\n    target: {\n      type: 'bpmn:Transaction',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Event Sub Process',\n    actionName: 'replace-with-event-subprocess',\n    className: 'bpmn-icon-event-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      triggeredByEvent: true,\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Sub Process (collapsed)',\n    actionName: 'replace-with-collapsed-subprocess',\n    className: 'bpmn-icon-subprocess-collapsed',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: false\n    }\n  }\n];\n\nmodule.exports.TRANSACTION = [\n  {\n    label: 'Sub Process',\n    actionName: 'replace-with-subprocess',\n    className: 'bpmn-icon-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Event Sub Process',\n    actionName: 'replace-with-event-subprocess',\n    className: 'bpmn-icon-event-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      triggeredByEvent: true,\n      isExpanded: true\n    }\n  }\n];\n\nmodule.exports.EVENT_SUB_PROCESS = [\n  {\n    label: 'Sub Process',\n    actionName: 'replace-with-subprocess',\n    className: 'bpmn-icon-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Transaction',\n    actionName: 'replace-with-transaction',\n    className: 'bpmn-icon-transaction',\n    target: {\n      type: 'bpmn:Transaction',\n      isExpanded: true\n    }\n  }\n];\n\nmodule.exports.TASK = [\n  {\n    label: 'Task',\n    actionName: 'replace-with-task',\n    className: 'bpmn-icon-task',\n    target: {\n      type: 'bpmn:Task'\n    }\n  },\n  {\n    label: 'Send Task',\n    actionName: 'replace-with-send-task',\n    className: 'bpmn-icon-send',\n    target: {\n      type: 'bpmn:SendTask'\n    }\n  },\n  {\n    label: 'Receive Task',\n    actionName: 'replace-with-receive-task',\n    className: 'bpmn-icon-receive',\n    target: {\n      type: 'bpmn:ReceiveTask'\n    }\n  },\n  {\n    label: 'User Task',\n    actionName: 'replace-with-user-task',\n    className: 'bpmn-icon-user',\n    target: {\n      type: 'bpmn:UserTask'\n    }\n  },\n  {\n    label: 'Manual Task',\n    actionName: 'replace-with-manual-task',\n    className: 'bpmn-icon-manual',\n    target: {\n      type: 'bpmn:ManualTask'\n    }\n  },\n  {\n    label: 'Business Rule Task',\n    actionName: 'replace-with-rule-task',\n    className: 'bpmn-icon-business-rule',\n    target: {\n      type: 'bpmn:BusinessRuleTask'\n    }\n  },\n  {\n    label: 'Service Task',\n    actionName: 'replace-with-service-task',\n    className: 'bpmn-icon-service',\n    target: {\n      type: 'bpmn:ServiceTask'\n    }\n  },\n  {\n    label: 'Script Task',\n    actionName: 'replace-with-script-task',\n    className: 'bpmn-icon-script',\n    target: {\n      type: 'bpmn:ScriptTask'\n    }\n  },\n  {\n    label: 'Call Activity',\n    actionName: 'replace-with-call-activity',\n    className: 'bpmn-icon-call-activity',\n    target: {\n      type: 'bpmn:CallActivity'\n    }\n  },\n  {\n    label: 'Sub Process (collapsed)',\n    actionName: 'replace-with-collapsed-subprocess',\n    className: 'bpmn-icon-subprocess-collapsed',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: false\n    }\n  },\n  {\n    label: 'Sub Process (expanded)',\n    actionName: 'replace-with-expanded-subprocess',\n    className: 'bpmn-icon-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: true\n    }\n  }\n];\n\nmodule.exports.BOUNDARY_EVENT = [\n  {\n    label: 'Message Boundary Event',\n    actionName: 'replace-with-message-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-message',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Boundary Event',\n    actionName: 'replace-with-timer-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-timer',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation Boundary Event',\n    actionName: 'replace-with-escalation-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-escalation',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Boundary Event',\n    actionName: 'replace-with-conditional-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-condition',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Error Boundary Event',\n    actionName: 'replace-with-error-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-error',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:ErrorEventDefinition'\n    }\n  },\n  {\n    label: 'Cancel Boundary Event',\n    actionName: 'replace-with-cancel-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-cancel',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:CancelEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Boundary Event',\n    actionName: 'replace-with-signal-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-signal',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation Boundary Event',\n    actionName: 'replace-with-compensation-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-compensation',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Message Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-message-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Timer Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-timer-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Escalation Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-escalation-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Conditional Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-conditional-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Signal Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-signal-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition',\n      cancelActivity: false\n    }\n  }\n];\n\nmodule.exports.EVENT_SUB_PROCESS_START_EVENT = [\n  {\n    label: 'Message Start Event',\n    actionName: 'replace-with-message-start',\n    className: 'bpmn-icon-start-event-message',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Start Event',\n    actionName: 'replace-with-timer-start',\n    className: 'bpmn-icon-start-event-timer',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Start Event',\n    actionName: 'replace-with-conditional-start',\n    className: 'bpmn-icon-start-event-condition',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Start Event',\n    actionName: 'replace-with-signal-start',\n    className: 'bpmn-icon-start-event-signal',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Error Start Event',\n    actionName: 'replace-with-error-start',\n    className: 'bpmn-icon-start-event-error',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ErrorEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation Start Event',\n    actionName: 'replace-with-escalation-start',\n    className: 'bpmn-icon-start-event-escalation',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation Start Event',\n    actionName: 'replace-with-compensation-start',\n    className: 'bpmn-icon-start-event-compensation',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Message Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-message-start',\n    className: 'bpmn-icon-start-event-non-interrupting-message',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Timer Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-timer-start',\n    className: 'bpmn-icon-start-event-non-interrupting-timer',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Conditional Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-conditional-start',\n    className: 'bpmn-icon-start-event-non-interrupting-condition',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Signal Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-signal-start',\n    className: 'bpmn-icon-start-event-non-interrupting-signal',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Escalation Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-escalation-start',\n    className: 'bpmn-icon-start-event-non-interrupting-escalation',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition',\n      isInterrupting: false\n    }\n  }\n];\n\nmodule.exports.SEQUENCE_FLOW = [\n  {\n    label: 'Sequence Flow',\n    actionName: 'replace-with-sequence-flow',\n    className: 'bpmn-icon-connection'\n  },\n  {\n    label: 'Default Flow',\n    actionName: 'replace-with-default-flow',\n    className: 'bpmn-icon-default-flow'\n  },\n  {\n    label: 'Conditional Flow',\n    actionName: 'replace-with-conditional-flow',\n    className: 'bpmn-icon-conditional-flow'\n  }\n];\n\nmodule.exports.PARTICIPANT = [\n  {\n    label: 'Expanded Pool',\n    actionName: 'replace-with-expanded-pool',\n    className: 'bpmn-icon-participant',\n    target: {\n      type: 'bpmn:Participant',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Collapsed Pool',\n    actionName: 'replace-with-collapsed-pool',\n    // TODO(@janstuemmel): maybe design new icon\n    className: 'bpmn-icon-lane',\n    target: {\n      type: 'bpmn:Participant',\n      isExpanded: false\n    }\n  }\n];\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/replace/BpmnReplace.js":"'use strict';\n\nvar pick = require('lodash/object/pick'),\n    assign = require('lodash/object/assign'),\n    intersection = require('lodash/array/intersection'),\n    filter = require('lodash/collection/filter'),\n    has = require('lodash/object/has');\n\nvar is = require('../../util/ModelUtil').is,\n    isExpanded = require('../../util/DiUtil').isExpanded,\n    isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,\n    ModelCloneUtils = require('../../util/model/ModelCloneUtils'),\n    getProperties = ModelCloneUtils.getProperties;\n\nvar IGNORED_PROPERTIES = ModelCloneUtils.IGNORED_PROPERTIES;\n\nvar ModelCloneHelper = require('../../util/model/ModelCloneHelper');\n\nvar CUSTOM_PROPERTIES = [\n  'cancelActivity',\n  'instantiate',\n  'eventGatewayType',\n  'triggeredByEvent',\n  'isInterrupting'\n];\n\n\nfunction toggeling(element, target) {\n\n  var oldCollapsed = has(element, 'collapsed') ?\n                     element.collapsed : !isExpanded(element);\n\n  var targetCollapsed;\n\n  if (has(target, 'collapsed') || has(target, 'isExpanded')) {\n    // property is explicitly set so use it\n    targetCollapsed = has(target, 'collapsed') ?\n                      target.collapsed : !target.isExpanded;\n  } else {\n    // keep old state\n    targetCollapsed = oldCollapsed;\n  }\n\n  if (oldCollapsed !== targetCollapsed) {\n    element.collapsed = oldCollapsed;\n    return true;\n  }\n\n  return false;\n}\n\n\n\n/**\n * This module takes care of replacing BPMN elements\n */\nfunction BpmnReplace(bpmnFactory, replace, selection, modeling, eventBus) {\n\n  var helper = new ModelCloneHelper(eventBus);\n\n  /**\n   * Prepares a new business object for the replacement element\n   * and triggers the replace operation.\n   *\n   * @param  {djs.model.Base} element\n   * @param  {Object} target\n   * @param  {Object} [hints]\n   *\n   * @return {djs.model.Base} the newly created element\n   */\n  function replaceElement(element, target, hints) {\n\n    hints = hints || {};\n\n    var type = target.type,\n        oldBusinessObject = element.businessObject;\n\n    if (is(oldBusinessObject, 'bpmn:SubProcess')) {\n      if (type === 'bpmn:SubProcess') {\n        if (toggeling(element, target)) {\n          // expanding or collapsing process\n          modeling.toggleCollapse(element);\n\n          return element;\n        }\n      }\n    }\n\n    var newBusinessObject = bpmnFactory.create(type);\n\n    var newElement = {\n      type: type,\n      businessObject: newBusinessObject\n    };\n\n    var elementProps = getProperties(oldBusinessObject.$descriptor),\n        newElementProps = getProperties(newBusinessObject.$descriptor, true),\n        properties = intersection(elementProps, newElementProps);\n\n    // initialize special properties defined in target definition\n    assign(newBusinessObject, pick(target, CUSTOM_PROPERTIES));\n\n    properties = filter(properties, function(property) {\n      var propName = property.replace(/bpmn:/, '');\n\n      // so the applied properties from 'target' don't get lost\n      if (newBusinessObject[property] !== undefined) {\n        return false;\n      }\n\n      // retain loop characteristics if the target element is not an event sub process\n      if (propName === 'loopCharacteristics') {\n        return !isEventSubProcess(newBusinessObject);\n      }\n\n      if ((propName === 'processRef' && target.isExpanded === false) ||\n           propName === 'triggeredByEvent' ||\n           propName === 'eventDefinitions') {\n        return false;\n      }\n\n      return IGNORED_PROPERTIES.indexOf(propName) === -1;\n    });\n\n    newBusinessObject = helper.clone(oldBusinessObject, newBusinessObject, properties);\n\n    // initialize custom BPMN extensions\n    if (target.eventDefinitionType) {\n      newElement.eventDefinitionType = target.eventDefinitionType;\n    }\n\n    if (is(oldBusinessObject, 'bpmn:Activity')) {\n\n      if (is(oldBusinessObject, 'bpmn:SubProcess')) {\n        // no toggeling, so keep old state\n        newElement.isExpanded = isExpanded(oldBusinessObject);\n      }\n      // else if property is explicitly set, use it\n      else if (has(target, 'isExpanded')) {\n        newElement.isExpanded = target.isExpanded;\n      }\n\n      // TODO: need also to respect min/max Size\n      // copy size, from an expanded subprocess to an expanded alternative subprocess\n      // except bpmn:Task, because Task is always expanded\n      if ((isExpanded(oldBusinessObject) && !is(oldBusinessObject, 'bpmn:Task')) && newElement.isExpanded) {\n        newElement.width = element.width;\n        newElement.height = element.height;\n      }\n    }\n\n    // transform collapsed/expanded pools\n    if (is(oldBusinessObject, 'bpmn:Participant')) {\n\n      // create expanded pool\n      if (target.isExpanded === true) {\n        newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');\n      } else {\n        // remove children when transforming to collapsed pool\n        hints.moveChildren = false;\n      }\n\n        // apply same size\n      newElement.width = element.width;\n      newElement.height = element.height;\n    }\n\n    newBusinessObject.name = oldBusinessObject.name;\n\n    // retain default flow's reference between inclusive <-> exclusive gateways and activities\n    if ((is(oldBusinessObject, 'bpmn:ExclusiveGateway') || is(oldBusinessObject, 'bpmn:InclusiveGateway') ||\n         is(oldBusinessObject, 'bpmn:Activity')) &&\n        (is(newBusinessObject, 'bpmn:ExclusiveGateway') || is(newBusinessObject, 'bpmn:InclusiveGateway') ||\n         is(newBusinessObject, 'bpmn:Activity')))\n    {\n      newBusinessObject.default = oldBusinessObject.default;\n    }\n\n    if ('fill' in oldBusinessObject.di || 'stroke' in oldBusinessObject.di) {\n      assign(newElement, { colors: pick(oldBusinessObject.di, [ 'fill', 'stroke' ]) });\n    }\n\n    newElement = replace.replaceElement(element, newElement, hints);\n\n    if (hints.select !== false) {\n      selection.select(newElement);\n    }\n\n    return newElement;\n  }\n\n  this.replaceElement = replaceElement;\n}\n\nBpmnReplace.$inject = [ 'bpmnFactory', 'replace', 'selection', 'modeling', 'eventBus' ];\n\nmodule.exports = BpmnReplace;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/replace-preview/BpmnReplacePreview.js":"'use strict';\n\nvar CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');\n\nvar inherits = require('inherits');\n\nvar assign = require('lodash/object/assign'),\n    forEach = require('lodash/collection/forEach');\n\nvar domQuery = require('min-dom/lib/query');\n\nvar svgAttr = require('tiny-svg/lib/attr');\n\nvar LOW_PRIORITY = 250;\n\nfunction BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Replace the visuals of all elements in the context which can be replaced\n   *\n   * @param  {Object} context\n   */\n  function replaceVisual(context) {\n\n    var replacements = context.canExecute.replacements;\n\n    forEach(replacements, function(replacement) {\n\n      var id = replacement.oldElementId;\n\n      var newElement = {\n        type: replacement.newElementType\n      };\n\n      // if the visual of the element is already replaced\n      if (context.visualReplacements[id]) {\n        return;\n      }\n\n      var element = elementRegistry.get(id);\n\n      assign(newElement, { x: element.x, y: element.y });\n\n      // create a temporary shape\n      var tempShape = elementFactory.createShape(newElement);\n\n      canvas.addShape(tempShape, element.parent);\n\n      // select the original SVG element related to the element and hide it\n      var gfx = domQuery('[data-element-id=' + element.id + ']', context.dragGroup);\n\n      if (gfx) {\n        svgAttr(gfx, { display: 'none' });\n      }\n\n      // clone the gfx of the temporary shape and add it to the drag group\n      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);\n\n      context.visualReplacements[id] = dragger;\n\n      canvas.removeShape(tempShape);\n    });\n  }\n\n  /**\n   * Restore the original visuals of the previously replaced elements\n   *\n   * @param  {Object} context\n   */\n  function restoreVisual(context) {\n\n    var visualReplacements = context.visualReplacements;\n\n    forEach(visualReplacements, function(dragger, id) {\n\n      var originalGfx = domQuery('[data-element-id=' + id + ']', context.dragGroup);\n\n      if (originalGfx) {\n        svgAttr(originalGfx, { display: 'inline' });\n      }\n\n      dragger.remove();\n\n      if (visualReplacements[id]) {\n        delete visualReplacements[id];\n      }\n    });\n  }\n\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        canExecute = context.canExecute;\n\n    if (!context.visualReplacements) {\n      context.visualReplacements = {};\n    }\n\n    if (canExecute.replacements) {\n      replaceVisual(context);\n    } else {\n      restoreVisual(context);\n    }\n  });\n}\n\nBpmnReplacePreview.$inject = [ 'eventBus', 'elementRegistry', 'elementFactory', 'canvas', 'previewSupport' ];\n\ninherits(BpmnReplacePreview, CommandInterceptor);\n\nmodule.exports = BpmnReplacePreview;\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/rules/BpmnRules.js":"'use strict';\n\nvar find = require('lodash/collection/find'),\n    any = require('lodash/collection/any'),\n    every = require('lodash/collection/every'),\n    filter = require('lodash/collection/filter'),\n    forEach = require('lodash/collection/forEach'),\n    inherits = require('inherits');\n\nvar is = require('../../util/ModelUtil').is,\n    isAny = require('../modeling/util/ModelingUtil').isAny,\n    getBusinessObject = require('../../util/ModelUtil').getBusinessObject,\n    isExpanded = require('../../util/DiUtil').isExpanded,\n    isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,\n    isInterrupting = require('../../util/DiUtil').isInterrupting,\n    hasErrorEventDefinition = require('../../util/DiUtil').hasErrorEventDefinition,\n    hasEscalationEventDefinition = require('../../util/DiUtil').hasEscalationEventDefinition,\n    hasCompensateEventDefinition = require('../../util/DiUtil').hasCompensateEventDefinition;\n\n\nvar RuleProvider = require('diagram-js/lib/features/rules/RuleProvider');\n\nvar isBoundaryAttachment = require('../snapping/BpmnSnappingUtil').getBoundaryAttachment;\n\n/**\n * BPMN specific modeling rule\n */\nfunction BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\n\ninherits(BpmnRules, RuleProvider);\n\nBpmnRules.$inject = [ 'eventBus' ];\n\nmodule.exports = BpmnRules;\n\nBpmnRules.prototype.init = function() {\n\n  this.addRule('connection.create', function(context) {\n    var source = context.source,\n        target = context.target;\n\n    return canConnect(source, target);\n  });\n\n  this.addRule('connection.reconnectStart', function(context) {\n\n    var connection = context.connection,\n        source = context.hover || context.source,\n        target = connection.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.reconnectEnd', function(context) {\n\n    var connection = context.connection,\n        source = connection.source,\n        target = context.hover || context.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.updateWaypoints', function(context) {\n    // OK! but visually ignore\n    return null;\n  });\n\n  this.addRule('shape.resize', function(context) {\n\n    var shape = context.shape,\n        newBounds = context.newBounds;\n\n    return canResize(shape, newBounds);\n  });\n\n  this.addRule('elements.move', function(context) {\n\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n\n    return canAttach(shapes, target, null, position) ||\n           canReplace(shapes, target, position) ||\n           canMove(shapes, target, position) ||\n           canInsert(shapes, target, position);\n  });\n\n  this.addRule([ 'shape.create', 'shape.append' ], function(context) {\n    var target = context.target,\n        shape = context.shape,\n        source = context.source,\n        position = context.position;\n\n    return canAttach([ shape ], target, source, position) || canCreate(shape, target, source, position);\n  });\n\n  this.addRule('element.copy', function(context) {\n    var collection = context.collection,\n        element = context.element;\n\n    return canCopy(collection, element);\n  });\n\n  this.addRule('element.paste', function(context) {\n    var parent = context.parent,\n        element = context.element,\n        position = context.position,\n        source = context.source,\n        target = context.target;\n\n    if (source || target) {\n      return canConnect(source, target);\n    }\n\n    return canAttach([ element ], parent, null, position) || canCreate(element, parent, null, position);\n  });\n\n  this.addRule('elements.paste', function(context) {\n    var tree = context.tree,\n        target = context.target;\n\n    return canPaste(tree, target);\n  });\n\n  this.addRule([ 'elements.delete' ], function(context) {\n\n    // do not allow deletion of labels\n    return filter(context.elements, function(e) {\n      return !isLabel(e);\n    });\n  });\n};\n\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\n\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\n\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\n\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\n\nBpmnRules.prototype.canMove = canMove;\n\nBpmnRules.prototype.canAttach = canAttach;\n\nBpmnRules.prototype.canReplace = canReplace;\n\nBpmnRules.prototype.canDrop = canDrop;\n\nBpmnRules.prototype.canInsert = canInsert;\n\nBpmnRules.prototype.canCreate = canCreate;\n\nBpmnRules.prototype.canConnect = canConnect;\n\nBpmnRules.prototype.canResize = canResize;\n\nBpmnRules.prototype.canCopy = canCopy;\n\n/**\n * Utility functions for rule checking\n */\n\nfunction nonExistantOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction getOrganizationalParent(element) {\n\n  var bo = getBusinessObject(element);\n\n  while (bo && !is(bo, 'bpmn:Process')) {\n    if (is(bo, 'bpmn:Participant')) {\n      return bo.processRef || bo;\n    }\n\n    bo = bo.$parent;\n  }\n\n  return bo;\n}\n\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') &&\n         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\nfunction isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}\n\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n\n  return parentA === parentB;\n}\n\nfunction isMessageFlowSource(element) {\n  return is(element, 'bpmn:InteractionNode') &&\n        !isForCompensation(element) && (\n            !is(element, 'bpmn:Event') || (\n              is(element, 'bpmn:ThrowEvent') &&\n              hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n            )\n  );\n}\n\nfunction isMessageFlowTarget(element) {\n  return is(element, 'bpmn:InteractionNode') &&\n        !isForCompensation(element) && (\n            !is(element, 'bpmn:Event') || (\n              is(element, 'bpmn:CatchEvent') &&\n              hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n            )\n  );\n}\n\nfunction getScopeParent(element) {\n\n  var bo = getBusinessObject(element);\n\n  if (is(bo, 'bpmn:Participant')) {\n    return null;\n  }\n\n  while (bo) {\n    bo = bo.$parent;\n\n    if (is(bo, 'bpmn:FlowElementsContainer')) {\n      return bo;\n    }\n  }\n\n  return bo;\n}\n\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n\n  return scopeParentA && (scopeParentA === scopeParentB);\n}\n\nfunction hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return !!find(bo.eventDefinitions || [], function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return (bo.eventDefinitions || []).every(function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction isSequenceFlowSource(element) {\n  return is(element, 'bpmn:FlowNode') &&\n        !is(element, 'bpmn:EndEvent') &&\n        !isEventSubProcess(element) &&\n        !(is(element, 'bpmn:IntermediateThrowEvent') &&\n          hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n        ) &&\n        !isCompensationBoundary(element) &&\n        !isForCompensation(element);\n}\n\nfunction isSequenceFlowTarget(element) {\n  return is(element, 'bpmn:FlowNode') &&\n        !is(element, 'bpmn:StartEvent') &&\n        !is(element, 'bpmn:BoundaryEvent') &&\n        !isEventSubProcess(element) &&\n        !(is(element, 'bpmn:IntermediateCatchEvent') &&\n          hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n        ) &&\n        !isForCompensation(element);\n\n}\n\nfunction isEventBasedTarget(element) {\n  return is(element, 'bpmn:ReceiveTask') || (\n         is(element, 'bpmn:IntermediateCatchEvent') && (\n           hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||\n           hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||\n           hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||\n           hasEventDefinition(element, 'bpmn:SignalEventDefinition')\n         )\n  );\n}\n\nfunction isLabel(element) {\n  return element.labelTarget;\n}\n\nfunction isConnection(element) {\n  return element.waypoints;\n}\n\nfunction getParents(element) {\n\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}\n\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\nfunction canConnect(source, target, connection) {\n\n  if (nonExistantOrLabel(source) || nonExistantOrLabel(target)) {\n    return null;\n  }\n\n  // See https://github.com/bpmn-io/bpmn-js/issues/178\n  // as a workround we disallow connections with same\n  // target and source element.\n  // This rule must be removed if a auto layout for this\n  // connections is implemented.\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n\n    if (canConnectMessageFlow(source, target)) {\n      return { type: 'bpmn:MessageFlow' };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return { type: 'bpmn:SequenceFlow' };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (is(connection, 'bpmn:Association') && canConnectAssociation(source, target)) {\n\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  if (isTextAnnotation(source) || isTextAnnotation(target)) {\n\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  return false;\n}\n\n/**\n * Can an element be dropped into the target element\n *\n * @return {Boolean}\n */\nfunction canDrop(element, target, position) {\n\n  // can move labels everywhere\n  if (isLabel(element) && !isConnection(target)) {\n    return true;\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // on existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent')) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation' ])) {\n    return isAny(target, [\n      'bpmn:Collaboration',\n      'bpmn:Lane',\n      'bpmn:Participant',\n      'bpmn:Process',\n      'bpmn:SubProcess' ]);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration')\n      || element.source.parent == target\n      || element.target.parent == target;\n  }\n\n  return false;\n}\n\nfunction canPaste(tree, target) {\n  var topLevel = tree[0],\n      participants;\n\n  if (is(target, 'bpmn:Collaboration')) {\n    return every(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n  }\n\n  if (is(target, 'bpmn:Process')) {\n    participants = any(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n\n    return !(participants && target.children.length > 0);\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  if (is(target, 'bpmn:FlowElementsContainer')) {\n    return isExpanded(target);\n  }\n\n  return isAny(target, [\n    'bpmn:Collaboration',\n    'bpmn:Lane',\n    'bpmn:Participant',\n    'bpmn:Process',\n    'bpmn:SubProcess' ]);\n}\n\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n\n/**\n * We treat IntermediateThrowEvents as boundary events during create,\n * this must be reflected in the rules.\n */\nfunction isBoundaryCandidate(element) {\n  return isBoundaryEvent(element) ||\n        (is(element, 'bpmn:IntermediateThrowEvent') && !element.parent);\n}\n\n\nfunction canAttach(elements, target, source, position) {\n\n  if (!Array.isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  // disallow appending as boundary event\n  if (source) {\n    return false;\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // allow default move operation\n  if (!target) {\n    return true;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  return 'attach';\n}\n\n\n/**\n * Defines how to replace elements for a given target.\n *\n * Returns an array containing all elements which will be replaced.\n *\n * @example\n *\n *  [{ id: 'IntermediateEvent_2',\n *     type: 'bpmn:StartEvent'\n *   },\n *   { id: 'IntermediateEvent_5',\n *     type: 'bpmn:EndEvent'\n *   }]\n *\n * @param  {Array} elements\n * @param  {Object} target\n *\n * @return {Object} an object containing all elements which have to be replaced\n */\nfunction canReplace(elements, target, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n\n  forEach(elements, function(element) {\n\n    if (!isEventSubProcess(target)) {\n\n      if (is(element, 'bpmn:StartEvent') &&\n          element.type !== 'label' &&\n          canDrop(element, target)) {\n\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compansate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) ||\n            hasEscalationEventDefinition(element) ||\n            hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&\n          element.type !== 'label') {\n\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n\n  return canExecute.replacements.length ? canExecute : false;\n}\n\nfunction canMove(elements, target) {\n\n  // do not move selection containing boundary events\n  if (any(elements, isBoundaryEvent)) {\n    return false;\n  }\n\n  // do not move selection containing lanes\n  if (any(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function(element) {\n    return canDrop(element, target);\n  });\n}\n\nfunction canCreate(shape, target, source, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(target)) {\n    return null;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return (!!isExpanded(shape)) && (\n          !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)\n    );\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction canConnectAssociation(source, target) {\n\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  }\n\n  // connect if different parent\n  return !isParent(target, source) &&\n         !isParent(source, target);\n}\n\nfunction canConnectMessageFlow(source, target) {\n\n  return isMessageFlowSource(source) &&\n         isMessageFlowTarget(target) &&\n        !isSameOrganization(source, target);\n}\n\nfunction canConnectSequenceFlow(source, target) {\n\n  return isSequenceFlowSource(source) &&\n         isSequenceFlowTarget(target) &&\n         isSameScope(source, target) &&\n         !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\n\nfunction canConnectDataAssociation(source, target) {\n\n  if (isAny(source, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(target, [ 'bpmn:Activity', 'bpmn:ThrowEvent' ])) {\n    return { type: 'bpmn:DataInputAssociation' };\n  }\n\n  if (isAny(target, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(source, [ 'bpmn:Activity', 'bpmn:CatchEvent' ])) {\n    return { type: 'bpmn:DataOutputAssociation' };\n  }\n\n  return false;\n}\n\nfunction canInsert(shape, flow, position) {\n\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[0];\n  }\n\n  // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n  return (\n    isAny(flow, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ]) &&\n    !isLabel(flow) &&\n    is(shape, 'bpmn:FlowNode') &&\n    !is(shape, 'bpmn:BoundaryEvent') &&\n    canDrop(shape, flow.parent, position));\n}\n\nfunction contains(collection, element) {\n  return (collection && element) && collection.indexOf(element) !== -1;\n}\n\nfunction canCopy(collection, element) {\n  if (is(element, 'bpmn:Lane') && !contains(collection, element.parent)) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent') && !contains(collection, element.host)) {\n    return false;\n  }\n\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/snapping/BpmnSnappingUtil.js":"'use strict';\n\nvar getOrientation = require('diagram-js/lib/layout/LayoutUtil').getOrientation;\n\n\nfunction getBoundaryAttachment(position, targetBounds) {\n\n  var orientation = getOrientation(position, targetBounds, -15);\n\n  if (orientation !== 'intersect') {\n    return orientation;\n  } else {\n    return null;\n  }\n}\n\nmodule.exports.getBoundaryAttachment = getBoundaryAttachment;\n\n\n\n// participant snapping box implementation /////////////////\n\nvar is = require('../../util/ModelUtil').is;\n\nvar asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL;\n\nvar collectLanes = require('../modeling/util/LaneUtil').collectLanes,\n    getLanesRoot = require('../modeling/util/LaneUtil').getLanesRoot;\n\nvar abs = Math.abs,\n    min = Math.min,\n    max = Math.max;\n\n\nfunction addToTrbl(trbl, attr, value, choice) {\n\n  var current = trbl[attr];\n\n  // make sure to set the value if it does not exist\n  // or apply the correct value by comparing against\n  // choice(value, currentValue)\n  trbl[attr] = current === undefined ? value : choice(value, current);\n}\n\nfunction addMin(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, min);\n}\n\nfunction addMax(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, max);\n}\n\n\nvar LANE_MIN_HEIGHT = 60,\n    LANE_MIN_WIDTH = 300,\n    LANE_RIGHT_PADDING = 20,\n    LANE_LEFT_PADDING = 50,\n    LANE_TOP_PADDING = 20,\n    LANE_BOTTOM_PADDING = 20;\n\n\nfunction getParticipantSizeConstraints(laneShape, resizeDirection, balanced) {\n\n  var lanesRoot = getLanesRoot(laneShape);\n\n  var isFirst = true,\n      isLast = true;\n\n  ///// max top/bottom size for lanes\n\n  var allLanes = collectLanes(lanesRoot, [ lanesRoot ]);\n\n  var laneTrbl = asTRBL(laneShape);\n\n  var maxTrbl = {},\n      minTrbl = {};\n\n  if (/e/.test(resizeDirection)) {\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\n  } else\n  if (/w/.test(resizeDirection)) {\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\n  }\n\n  allLanes.forEach(function(other) {\n\n    var otherTrbl = asTRBL(other);\n\n    if (/n/.test(resizeDirection)) {\n\n      if (otherTrbl.top < (laneTrbl.top - 10)) {\n        isFirst = false;\n      }\n\n      // max top size (based on next element)\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n\n      // min top size (based on self or nested element)\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n    }\n\n    if (/s/.test(resizeDirection)) {\n\n      if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {\n        isLast = false;\n      }\n\n      // max bottom size (based on previous element)\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n\n      // min bottom size (based on self or nested element)\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n    }\n  });\n\n\n  ///// max top/bottom/left/right size based on flow nodes\n\n  var flowElements = lanesRoot.children.filter(function(s) {\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\n  });\n\n  flowElements.forEach(function(flowElement) {\n\n    var flowElementTrbl = asTRBL(flowElement);\n\n    if (isFirst && /n/.test(resizeDirection)) {\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\n    }\n\n    if (/e/.test(resizeDirection)) {\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\n    }\n\n    if (isLast && /s/.test(resizeDirection)) {\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\n    }\n\n    if (/w/.test(resizeDirection)) {\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\n    }\n  });\n\n\n  return {\n    min: minTrbl,\n    max: maxTrbl\n  };\n}\n\n\nmodule.exports.getParticipantSizeConstraints = getParticipantSizeConstraints;","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/search/BpmnSearchProvider.js":"'use strict';\n\nvar map = require('lodash/collection/map'),\n    filter = require('lodash/collection/filter'),\n    sortBy = require('lodash/collection/sortBy');\n\nvar labelUtil = require('../label-editing/LabelUtil');\n\n\n/**\n * Provides ability to search through BPMN elements\n */\nfunction BpmnSearchProvider(elementRegistry, searchPad, canvas) {\n\n  this._elementRegistry = elementRegistry;\n  this._canvas = canvas;\n\n  searchPad.registerProvider(this);\n}\n\nmodule.exports = BpmnSearchProvider;\n\nBpmnSearchProvider.$inject = [\n  'elementRegistry',\n  'searchPad',\n  'canvas'\n];\n\n\n/**\n * Finds all elements that match given pattern\n *\n * <Result> :\n *  {\n *    primaryTokens: <Array<Token>>,\n *    secondaryTokens: <Array<Token>>,\n *    element: <Element>\n *  }\n *\n * <Token> :\n *  {\n *    normal|matched: <String>\n *  }\n *\n * @param  {String} pattern\n * @return {Array<Result>}\n */\nBpmnSearchProvider.prototype.find = function(pattern) {\n  var rootElement = this._canvas.getRootElement();\n\n  var elements = this._elementRegistry.filter(function(element) {\n    if (element.labelTarget) {\n      return false;\n    }\n    return true;\n  });\n\n  // do not include root element\n  elements = filter(elements, function(element) {\n    return element !== rootElement;\n  });\n\n  elements = map(elements, function(element) {\n    return {\n      primaryTokens: matchAndSplit(labelUtil.getLabel(element), pattern),\n      secondaryTokens: matchAndSplit(element.id, pattern),\n      element: element\n    };\n  });\n\n  // exclude non-matched elements\n  elements = filter(elements, function(element) {\n    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);\n  });\n\n  elements = sortBy(elements, function(element) {\n    return labelUtil.getLabel(element.element) + element.element.id;\n  });\n\n  return elements;\n};\n\n\nfunction hasMatched(tokens) {\n  var matched = filter(tokens, function(t) {\n    return !!t.matched;\n  });\n\n  return matched.length > 0;\n}\n\n\nfunction matchAndSplit(text, pattern) {\n  var tokens = [],\n      originalText = text;\n\n  if (!text) {\n    return tokens;\n  }\n\n  text = text.toLowerCase();\n  pattern = pattern.toLowerCase();\n\n  var i = text.indexOf(pattern);\n\n  if (i > -1) {\n    if (i !== 0) {\n      tokens.push({\n        normal: originalText.substr(0, i)\n      });\n    }\n\n    tokens.push({\n      matched: originalText.substr(i, pattern.length)\n    });\n\n    if (pattern.length + i < text.length) {\n      tokens.push({\n        normal: originalText.substr(pattern.length + i, text.length)\n      });\n    }\n  } else {\n    tokens.push({\n      normal: originalText\n    });\n  }\n\n  return tokens;\n}","/home/travis/build/npmtest/node-npmtest-bpmn-js/node_modules/bpmn-js/lib/features/snapping/BpmnSnapping.js":"'use strict';\n\nvar inherits = require('inherits');\n\nvar abs = Math.abs;\n\nvar forEach = require('lodash/collection/forEach'),\n    filter = require('lodash/collection/filter'),\n    assign = require('lodash/object/assign');\n\nvar getBoundingBox = require('diagram-js/lib/util/Elements').getBBox;\n\nvar is = require('../../util/ModelUtil').is,\n    isAny = require('../modeling/util/ModelingUtil').isAny,\n    isExpanded = require('../../util/DiUtil').isExpanded;\n\nvar Snapping = require('diagram-js/lib/features/snapping/Snapping'),\n    SnapUtil = require('diagram-js/lib/features/snapping/SnapUtil');\n\nvar asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL;\n\nvar round = Math.round;\n\nvar mid = SnapUtil.mid,\n    topLeft = SnapUtil.topLeft,\n    bottomRight = SnapUtil.bottomRight,\n    isSnapped = SnapUtil.isSnapped,\n    setSnapped = SnapUtil.setSnapped;\n\nvar getBoundaryAttachment = require('./BpmnSnappingUtil').getBoundaryAttachment,\n    getParticipantSizeConstraints = require('./BpmnSnappingUtil').getParticipantSizeConstraints,\n    getLanesRoot = require('../modeling/util/LaneUtil').getLanesRoot;\n\nvar HIGH_PRIORITY = 1500;\n\n\n/**\n * BPMN specific snapping functionality\n *\n *  * snap on process elements if a pool is created inside a\n *    process diagram\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nfunction BpmnSnapping(eventBus, canvas, bpmnRules, elementRegistry) {\n\n  // instantiate super\n  Snapping.call(this, eventBus, canvas);\n\n\n  /**\n   * Drop participant on process <> process elements snapping\n   */\n  eventBus.on('create.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n  eventBus.on([ 'create.move', 'create.end' ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        participantSnapBox = context.participantSnapBox;\n\n    if (!isSnapped(event) && participantSnapBox) {\n      snapParticipant(participantSnapBox, shape, event);\n    }\n  });\n\n  eventBus.on('shape.move.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n\n  function canAttach(shape, target, position) {\n    return bpmnRules.canAttach([ shape ], target, null, position) === 'attach';\n  }\n\n  function canConnect(source, target) {\n    return bpmnRules.canConnect(source, target);\n  }\n\n  /**\n   * Snap boundary events to elements border\n   */\n  eventBus.on([\n    'create.move',\n    'create.end',\n    'shape.move.move',\n    'shape.move.end'\n  ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        target = context.target,\n        shape = context.shape;\n\n    if (target && !isSnapped(event) && canAttach(shape, target, event)) {\n      snapBoundaryEvent(event, shape, target);\n    }\n  });\n\n  /**\n   * Adjust parent for flowElements to the target participant\n   * when droping onto lanes.\n   */\n  eventBus.on([\n    'shape.move.hover',\n    'shape.move.move',\n    'shape.move.end',\n    'create.hover',\n    'create.move',\n    'create.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape,\n        hover = event.hover;\n\n    if (is(hover, 'bpmn:Lane') && !isAny(shape, [ 'bpmn:Lane', 'bpmn:Participant' ])) {\n      event.hover = getLanesRoot(hover);\n      event.hoverGfx = elementRegistry.getGraphics(event.hover);\n    }\n  });\n\n  /**\n   * Snap sequence flows.\n   */\n  eventBus.on([\n    'connect.move',\n    'connect.hover',\n    'connect.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        source = context.source,\n        target = context.target;\n\n    var connection = canConnect(source, target) || {};\n\n    if (!context.initialSourcePosition) {\n      context.initialSourcePosition = context.sourcePosition;\n    }\n\n    if (target && connection.type === 'bpmn:SequenceFlow') {\n\n      // snap source\n      context.sourcePosition = mid(source);\n\n      // snap target\n      assign(event, mid(target));\n    } else {\n\n      // otherwise reset source snap\n      context.sourcePosition = context.initialSourcePosition;\n    }\n\n  });\n\n\n  eventBus.on([\n    'create.move',\n    'shape.move.move'\n  ], function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        target = context.target;\n\n    var threshold = 30;\n\n    if (is(shape, 'bpmn:Lane')) {\n      if (isAny(target, [ 'bpmn:Lane', 'bpmn:Participant' ])) {\n\n        var childLanes = filter(target.children, function(c) {\n          return is(c, 'bpmn:Lane');\n        });\n\n        var y = event.y,\n            targetTrbl;\n\n        var insert = childLanes.reduce(function(insert, l) {\n\n          var laneTrbl = asTRBL(l);\n\n          if (abs(laneTrbl.top - y) < threshold) {\n            insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });\n          } else\n          if (abs(laneTrbl.bottom - y) < threshold) {\n            insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });\n          } else\n          if (laneTrbl.top < y && laneTrbl.bottom > y) {\n            if (abs(laneTrbl.top - y) > abs(laneTrbl.bottom - y)) {\n              insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });\n            } else {\n              insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });\n            }\n\n          }\n\n          return insert;\n        }, false);\n\n\n        if (!insert) {\n          targetTrbl = asTRBL(target);\n\n          if (abs(targetTrbl.top - y) < threshold) {\n            insert = { before: { element: target, y: targetTrbl.top } };\n          } else\n          if (abs(targetTrbl.bottom - y) < threshold) {\n            insert = { after: { element: target, y: targetTrbl.bottom } };\n          } else {\n            insert = { into: { element: target, y: (targetTrbl.top + targetTrbl.bottom) / 2 } };\n          }\n\n        }\n\n        if (insert.before && insert.after) {\n          console.log('insert between', insert.before.element.id, 'and', insert.after.element.id);\n          setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);\n          setSnapped(event, 'y', insert.before.y);\n        } else\n        if (insert.after) {\n          console.log('insert after', insert.after.element.id);\n          setSnapped(event, 'x', insert.after.element.x + insert.after.element.width / 2);\n          setSnapped(event, 'y', insert.after.y);\n        } else\n        if (insert.before) {\n          console.log('insert before', insert.before.element.id);\n          setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);\n          setSnapped(event, 'y', insert.before.y);\n        } else\n        if (insert.into) {\n          console.log('insert into', insert.into.element.id);\n          setSnapped(event, 'x', insert.into.element.x + insert.into.element.width / 2);\n          setSnapped(event, 'y', insert.into.y);\n        }\n      }\n    }\n\n  });\n\n  eventBus.on('resize.start', HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n      context.minDimensions = { width: 140, height: 120 };\n    }\n\n    if (is(shape, 'bpmn:Participant')) {\n      context.minDimensions = { width: 300, height: 150 };\n    }\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n      context.resizeConstraints = getParticipantSizeConstraints(shape, context.direction, context.balanced);\n    }\n\n    if (is(shape, 'bpmn:TextAnnotation')) {\n      context.minDimensions = { width: 50, height: 30 };\n    }\n  });\n\n}\n\ninherits(BpmnSnapping, Snapping);\n\nBpmnSnapping.$inject = [ 'eventBus', 'canvas', 'bpmnRules', 'elementRegistry' ];\n\nmodule.exports = BpmnSnapping;\n\n\nBpmnSnapping.prototype.initSnap = function(event) {\n\n  var context = event.context,\n      shape = event.shape,\n      shapeMid,\n      shapeBounds,\n      shapeTopLeft,\n      shapeBottomRight,\n      snapContext;\n\n\n  snapContext = Snapping.prototype.initSnap.call(this, event);\n\n  if (is(shape, 'bpmn:Participant')) {\n    // assign higher priority for outer snaps on participants\n    snapContext.setSnapLocations([ 'top-left', 'bottom-right', 'mid' ]);\n  }\n\n\n  if (shape) {\n\n    shapeMid = mid(shape, event);\n\n    shapeBounds = {\n      width: shape.width,\n      height: shape.height,\n      x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,\n      y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y\n    };\n\n    shapeTopLeft = topLeft(shapeBounds);\n    shapeBottomRight = bottomRight(shapeBounds);\n\n    snapContext.setSnapOrigin('top-left', {\n      x: shapeTopLeft.x - event.x,\n      y: shapeTopLeft.y - event.y\n    });\n\n    snapContext.setSnapOrigin('bottom-right', {\n      x: shapeBottomRight.x - event.x,\n      y: shapeBottomRight.y - event.y\n    });\n\n    forEach(shape.outgoing, function(c) {\n      var docking = c.waypoints[0];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n    forEach(shape.incoming, function(c) {\n      var docking = c.waypoints[c.waypoints.length - 1];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n  }\n\n  var source = context.source;\n\n  if (source) {\n    snapContext.addDefaultSnap('mid', mid(source));\n  }\n};\n\n\nBpmnSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\n\n  // use target parent as snap target\n  if (is(shape, 'bpmn:BoundaryEvent') && shape.type !== 'label') {\n    target = target.parent;\n  }\n\n  // add sequence flow parents as snap targets\n  if (is(target, 'bpmn:SequenceFlow')) {\n    this.addTargetSnaps(snapPoints, shape, target.parent);\n  }\n\n  var siblings = this.getSiblings(shape, target) || [];\n\n  forEach(siblings, function(s) {\n\n    // do not snap to lanes\n    if (is(s, 'bpmn:Lane')) {\n      return;\n    }\n\n    snapPoints.add('mid', mid(s));\n\n    if (is(s, 'bpmn:Participant')) {\n      snapPoints.add('top-left', topLeft(s));\n      snapPoints.add('bottom-right', bottomRight(s));\n    }\n  });\n\n\n  forEach(shape.incoming, function(c) {\n\n    if (siblings.indexOf(c.source) === -1) {\n      snapPoints.add('mid', mid(c.source));\n    }\n\n    var docking = c.waypoints[0];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n\n\n  forEach(shape.outgoing, function(c) {\n\n    if (siblings.indexOf(c.target) === -1) {\n      snapPoints.add('mid', mid(c.target));\n    }\n\n    var docking = c.waypoints[c.waypoints.length - 1];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n};\n\n\n/////// participant snapping //////////////////\n\nfunction initParticipantSnapping(context, shape, elements) {\n\n  if (!elements.length) {\n    return;\n  }\n\n  var snapBox = getBoundingBox(elements.filter(function(e) {\n    return !e.labelTarget && !e.waypoints;\n  }));\n\n  snapBox.x -= 50;\n  snapBox.y -= 20;\n  snapBox.width += 70;\n  snapBox.height += 40;\n\n  // adjust shape height to include bounding box\n  shape.width = Math.max(shape.width, snapBox.width);\n  shape.height = Math.max(shape.height, snapBox.height);\n\n  context.participantSnapBox = snapBox;\n}\n\nfunction snapParticipant(snapBox, shape, event, offset) {\n  offset = offset || 0;\n\n  var shapeHalfWidth = shape.width / 2 - offset,\n      shapeHalfHeight = shape.height / 2;\n\n  var currentTopLeft = {\n    x: event.x - shapeHalfWidth - offset,\n    y: event.y - shapeHalfHeight\n  };\n\n  var currentBottomRight = {\n    x: event.x + shapeHalfWidth + offset,\n    y: event.y + shapeHalfHeight\n  };\n\n  var snapTopLeft = snapBox,\n      snapBottomRight = bottomRight(snapBox);\n\n  if (currentTopLeft.x >= snapTopLeft.x) {\n    setSnapped(event, 'x', snapTopLeft.x + offset + shapeHalfWidth);\n  } else\n  if (currentBottomRight.x <= snapBottomRight.x) {\n    setSnapped(event, 'x', snapBottomRight.x - offset - shapeHalfWidth);\n  }\n\n  if (currentTopLeft.y >= snapTopLeft.y) {\n    setSnapped(event, 'y', snapTopLeft.y + shapeHalfHeight);\n  } else\n  if (currentBottomRight.y <= snapBottomRight.y) {\n    setSnapped(event, 'y', snapBottomRight.y - shapeHalfHeight);\n  }\n}\n\n\n/////// boundary event snapping /////////////////////////\n\n\nfunction snapBoundaryEvent(event, shape, target) {\n  var targetTRBL = asTRBL(target);\n\n  var direction = getBoundaryAttachment(event, target);\n\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top);\n  } else\n  if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom);\n  }\n\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left);\n  } else\n  if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right);\n  }\n}\n"}